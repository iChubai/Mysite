{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Welcome to HouJiadong's Site! \ud83c\udf89  <p>  My frineds! /  About Me /   Academic Page /  Statistics </p> <li>Website Operating Time: </li> <li>Total Visitors:  people</li> <li>Total Visits:  times</li>"},{"location":"academy/","title":"Jiadong Hou(\u4faf\u5609\u680b)","text":""},{"location":"academy/#jiadong-hou","title":"Jiadong Hou(\u4faf\u5609\u680b)","text":"<p> Work Email: 2311671 [at] mail [at] nankai [dot] edu [dot] cn</p> <p> Personal Email: 2506676943 [at] qq [dot] com</p> <p> CV: Click Here</p> <p> </p>"},{"location":"academy/#bio","title":"Bio","text":"<p>I am a second-year undergraduate student majoring in Computer Science at  Nankai University (NKU). Currently, I am an intern at Hvision, under the guidance of Prof. Qibin Hou.</p>"},{"location":"academy/#research-interest","title":"Research Interest","text":"<ul> <li>Computer Vision: I am committed to the CV field, especially in the field of visual object tracking and kownledge distillation.</li> </ul>"},{"location":"academy/#education","title":"Education","text":""},{"location":"academy/#college-of-computer-science-nankai-university","title":"College of Computer Science, Nankai University","text":"<p>Sept. 2023 -- Present</p>"},{"location":"academy/#publications-manuscripts","title":"Publications &amp; Manuscripts","text":"<p>Coming soon...</p>"},{"location":"academy/#experience","title":"Experience","text":"<p>VCIP</p> <p>Dec. 2024 - Present</p> <p>Research Intern</p>"},{"location":"academy/#projects","title":"Projects","text":"<p>Coming soon...</p>"},{"location":"academy/#media-exposures","title":"Media Exposures","text":"<p>I write articles and share my thinkings on Zhihu regularly and have 200+ followers so far!</p>"},{"location":"academy/#honors","title":"Honors","text":"<ul> <li>Scholarship of Public Interests and All-Round Capability, 2024 </li> <li>Second Prize of the National College Students Mathematical Modeling Contest (Tianjin Division)</li> <li>First prize of the 16<sup>th</sup> Chinese Mathematics Competitions and first prize of the  Tianjin Mathematics Competitions(2024)</li> </ul>"},{"location":"about/","title":"About","text":""},{"location":"about/#about","title":"About \ud83e\udd73","text":"<p> \u7ea6 70 \u4e2a\u5b57  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4\u4e0d\u5230 1 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p> \u4e2d\u6587English <p>\u6211\u662f\u5357\u5f00\u5927\u5b66\u8ba1\u7b97\u673a\u79d1\u5b66\u4e0e\u6280\u672f\u4e13\u4e1a\u7684\u5927\u4e8c\u672c\u79d1\u751f\uff0c\u76ee\u524d\u611f\u5174\u8da3\u7684\u65b9\u5411\u662f\u8ba1\u7b97\u673a\u89c6\u89c9\uff08CV\uff09\u3002\u591a\u591a\u6307\u6559~    </p> <p>I am a sophomore in Nankai University majoring in Computer Science and Technology. My interests are in computer vision (CV). Thank you for your guidance!</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/#blog","title":"Blog","text":"<p> \u7ea6 1 \u4e2a\u5b57  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4\u4e0d\u5230 1 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p>"},{"location":"blogs/","title":"index","text":""},{"location":"blogs/#blogs","title":"Blogs \u270d","text":"<p>Abstract</p> <p>\u4e2a\u4eba\u535a\u5ba2\uff0c\u4e3b\u8981\u8bb0\u5f55</p> <ul> <li>\u5728\u8ba1\u7b97\u673a\u3001\u4eba\u5de5\u667a\u80fd\u3001\u6570\u5b66\u76f8\u5173\u65b9\u9762\u7684\u5b66\u4e60\uff0c\u4e5f\u4f1a\u63ba\u6742\u4e00\u4e9b\u5176\u5b83\u7684\u9886\u57df\uff1b</li> <li>\u8bfb\u4e66\u6458\u5f55\uff0c\u53ef\u80fd\u4f1a\u6709\u4e00\u4e9b\u7b14\u8bb0\uff1b</li> <li>\u4e00\u4e9b\u6742\u8c08\u3002</li> </ul> <p>\u4e00\u4e9b\u6bd4\u8f83\u6210\u4f53\u7cfb\u7684\u7b14\u8bb0\u4f1a\u8bb0\u5f55\u5728 Notes \u4e2d\u3002</p> <p>\u672c\u90e8\u5206\u5185\u5bb9\uff08\u9664\u7279\u522b\u58f0\u660e\u5916\uff09\u91c7\u7528 \u7f72\u540d-\u975e\u5546\u4e1a\u6027\u4f7f\u7528-\u4fdd\u6301\u4e00\u81f4 4.0 \u56fd\u9645 (CC BY-NC-SA 4.0) \u8bb8\u53ef\u534f\u8bae\u8fdb\u884c\u8bb8\u53ef\u3002</p>"},{"location":"blogs/#archives","title":"Archives","text":"<p>\u5982\u679c\u5bfb\u627e\u4e0d\u65b9\u4fbf\u7684\u8bdd\uff0c\u4e0d\u59a8\u8bd5\u8bd5\u641c\u7d22\u6216\u8005\u524d\u5f80 Tags \u9875\u9762</p> <p>{{ blog_content }}</p>"},{"location":"links/","title":"Links","text":""},{"location":"links/#links","title":"Links \ud83e\udd70","text":"<p>Abstract</p> <p>My friends!</p> Kinnariya Mama Tanha's Blogs \u5927\u4f6c(\u5d07\u62dc\u8138qwq) <p>\u5728\u4e0b\u65b9\u7559\u8a00\u7533\u8bf7\u52a0\u5165\u6211\u7684\u53cb\u94fe\uff0c\u6309\u5982\u4e0b\u683c\u5f0f\u63d0\u4f9b\u4fe1\u606f\uff1a</p> <ul><li>\u540d\u79f0\uff1aKinnari's Site</li><li>\u7b80\u4ecb\uff1aKinnariya Mama Tanha</li><li>\u94fe\u63a5\uff1ahttps://kinnariyamamatanha.github.io/</li><li>\u56fe\u7247\uff1aLink of your avatar</li></ul>"},{"location":"notes/","title":"index","text":""},{"location":"notes/#notes","title":"Notes \ud83d\udcda","text":"<p>Abstract</p> <p>\u4e00\u4e9b\u6bd4\u8f83\u6210\u4f53\u7cfb\u7684\u7b14\u8bb0\u90fd\u505a\u5728\u8fd9\u91cc\uff0c\u65b9\u4fbf\u67e5\u9605\u3002</p> <p>\u672c\u90e8\u5206\u5185\u5bb9\uff08\u9664\u7279\u522b\u58f0\u660e\u5916\uff09\u91c7\u7528 \u7f72\u540d-\u975e\u5546\u4e1a\u6027\u4f7f\u7528-\u4fdd\u6301\u4e00\u81f4 4.0 \u56fd\u9645 (CC BY-NC-SA 4.0) \u8bb8\u53ef\u534f\u8bae\u8fdb\u884c\u8bb8\u53ef\u3002</p>"},{"location":"notes/CMU15418/modernmulticoreprocessors/","title":"2 Modern multicore processors","text":""},{"location":"notes/CMU15418/modernmulticoreprocessors/#lecture-2-a-modern-multi-core-processor","title":"Lecture 2: A Modern Multi-Core Processor","text":"<p> \u7ea6 274 \u4e2a\u5b57  49 \u884c\u4ee3\u7801  1 \u5f20\u56fe\u7247  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 2 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p> <p>CMU 15-418/15-618, Fall 2018 </p>"},{"location":"notes/CMU15418/modernmulticoreprocessors/#key-concepts","title":"Key Concepts","text":"<ol> <li>Parallel Execution    - Multi-core processing    - SIMD (Single Instruction, Multiple Data)    - Instruction-Level Parallelism (ILP)  </li> <li>Memory Access Challenges    - Latency vs. Bandwidth    - Caching, Prefetching, Multi-threading  </li> </ol>"},{"location":"notes/CMU15418/modernmulticoreprocessors/#part-1-parallel-execution","title":"Part 1: Parallel Execution","text":""},{"location":"notes/CMU15418/modernmulticoreprocessors/#example-computing-sinx-using-taylor-expansion","title":"Example: Computing \\(\\sin(x)\\) Using Taylor Expansion","text":"<p>Formula: \\(\\(\\sin(x) = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\frac{x^7}{7!} + \\ldots\\)\\) </p> <p>Serial Code: </p>C<pre><code>void sinx(int N, int terms, float* x, float* result) {  \n    for (int i = 0; i &lt; N; i++) {  \n        float value = x[i];  \n        float numer = x[i] * x[i] * x[i];  \n        int denom = 6;  // 3!  \n        int sign = -1;  \n        for (int j = 1; j &lt;= terms; j++) {  \n            value += sign * numer / denom;  \n            numer *= x[i] * x[i];  \n            denom *= (2*j+2) * (2*j+3);  \n            sign *= -1;  \n        }  \n        result[i] = value;  \n    }  \n}  \n</code></pre> <p>Problem: No parallelism \u2192 Slower on multi-core (0.75x speedup per core).  </p>"},{"location":"notes/CMU15418/modernmulticoreprocessors/#parallelizing-with-pthreads","title":"Parallelizing with Pthreads","text":"<p>Data-Parallel Approach: </p>C<pre><code>void sinx(int N, int terms, float* x, float* result) {  \n    forall(int i from 0 to N-1) {  // Independent iterations  \n        float value = x[i];  \n        float numer = x[i] * x[i] * x[i];  \n        int denom = 6;  \n        int sign = -1;  \n        for (int j = 1; j &lt;= terms; j++) {  \n            value += sign * numer / denom;  \n            numer *= x[i] * x[i];  \n            denom *= (2*j+2) * (2*j+3);  \n            sign *= -1;  \n        }  \n        result[i] = value;  \n    }  \n}  \n</code></pre> Compiler Hint: Use <code>forall</code> to declare independent loop iterations."},{"location":"notes/CMU15418/modernmulticoreprocessors/#multi-core-scaling","title":"Multi-Core Scaling","text":"Cores Performance 1 1x 2 1.5x 4 3x 16 12x <p>Example Architectures: - Intel Core i7 (6 cores) - NVIDIA GTX 1080 (20 SMs) - Apple A9 (2 cores)  </p>"},{"location":"notes/CMU15418/modernmulticoreprocessors/#simd-vectorization","title":"SIMD Vectorization","text":"<p>AVX Intrinsics Example: </p>C<pre><code>#include &lt;immintrin.h&gt;  \nvoid sinx(int N, int terms, float* x, float* result) {  \n    float three_fact = 6;  \n    for (int i = 0; i &lt; N; i += 8) {  \n        __m256 origx = _mm256_load_ps(&amp;x[i]);  \n        __m256 value = origx;  \n        __m256 numer = _mm256_mul_ps(origx, _mm256_mul_ps(origx, origx));  \n        __m256 denom = _mm256_broadcast_ss(&amp;three_fact);  \n        int sign = -1;  \n        for (int j = 1; j &lt;= terms; j++) {  \n            __m256 tmp = _mm256_div_ps(_mm256_mul_ps(_mm256_set1_ps(sign), numer), denom);  \n            value = _mm256_add_ps(value, tmp);  \n            numer = _mm256_mul_ps(numer, _mm256_mul_ps(origx, origx));  \n            denom = _mm256_mul_ps(denom, _mm256_broadcast_ss((2*j+2)*(2*j+3)));  \n            sign *= -1;  \n        }  \n        _mm256_store_ps(&amp;result[i], value);  \n    }  \n}  \n</code></pre> Effect: 8 elements processed per instruction \ud83d\ude80."},{"location":"notes/CMU15418/modernmulticoreprocessors/#part-2-memory-access","title":"Part 2: Memory Access","text":""},{"location":"notes/CMU15418/modernmulticoreprocessors/#latency-vs-bandwidth","title":"Latency vs. Bandwidth","text":"<ul> <li>Latency: Time to service a memory request (e.g., 100 cycles).  </li> <li>Bandwidth: Data transfer rate (e.g., 20 GB/s).  </li> </ul>"},{"location":"notes/CMU15418/modernmulticoreprocessors/#techniques-to-mitigate-latency","title":"Techniques to Mitigate Latency","text":"<ol> <li>Caching: Reduce access time for frequently used data.  </li> <li>Prefetching: Predict and load data before it\u2019s needed.  </li> <li>Multi-threading: Hide latency by switching threads.  </li> </ol>"},{"location":"notes/CMU15418/modernmulticoreprocessors/#multi-threading-trade-offs","title":"Multi-Threading Trade-offs","text":"Scenario Pros Cons Single Thread Simple Frequent stalls 4 Hardware Threads Better ALU utilization Increased cache pressure 16 SIMD Cores High throughput Requires massive parallelism <p>Example: NVIDIA GTX 480 (15 cores, 32 ALUs/core, 1.3 TFLOPS).  </p>"},{"location":"notes/CMU15418/modernmulticoreprocessors/#gpu-vs-cpu-memory-hierarchy","title":"GPU vs. CPU Memory Hierarchy","text":"<p> - CPU: Large caches, low latency. - GPU: High bandwidth, optimized for throughput.  </p>"},{"location":"notes/CMU15418/modernmulticoreprocessors/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Parallel Execution Forms:    - Multi-core (thread-level)    - SIMD (data-level)    - Superscalar (ILP)  </li> <li>Memory Challenges:    - Bandwidth-bound programs need high arithmetic intensity.    - Optimize for data reuse and locality.  </li> <li>Hardware Trends:    - Simpler cores + more parallelism &gt; complex cores.    - GPUs push throughput to extremes.  </li> </ol> <p>\ud83d\udd0d Pro Tip: Use <code>forall</code> and vectorization to exploit parallelism!  </p>"},{"location":"notes/CMU15418/whyparallelism/","title":"1 why parallelism","text":""},{"location":"notes/CMU15418/whyparallelism/#historical-context-of-parallel-computing","title":"\ud83d\udd70\ufe0f Historical Context of Parallel Computing","text":"<p> \u7ea6 165 \u4e2a\u5b57  7 \u5f20\u56fe\u7247  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 1 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p>"},{"location":"notes/CMU15418/whyparallelism/#1970s2000s-supercomputers-databases","title":"\u25a0 1970s\u20132000s: Supercomputers &amp; Databases","text":"<ul> <li>C.mmp at CMU (1971): 16 PDP-11 processors. </li> <li>Cray XMP (1984): 4 vector processors. </li> <li>Sun Enterprise 10000 (1997): 16 UltraSPARC-II processors. </li> </ul>"},{"location":"notes/CMU15418/whyparallelism/#inflection-point-2004","title":"\u25a0 Inflection Point (2004)","text":"<ul> <li>Power Density Wall: Intel abandons frequency scaling, shifts to multi-core CPUs. </li> </ul>"},{"location":"notes/CMU15418/whyparallelism/#key-concepts","title":"\ud83d\udca1 Key Concepts","text":""},{"location":"notes/CMU15418/whyparallelism/#speedup-formula","title":"\u25a0 Speedup Formula","text":"\\[\\text{Speedup}(P) = \\frac{\\text{Execution Time (1 processor)}}{\\text{Execution Time (P processors)}}\\] <p>Demo Observations: 1. Demo 1: Communication limits speedup. 2. Demo 2: Work imbalance reduces efficiency. 3. Demo 3: Communication dominates computation.  </p>"},{"location":"notes/CMU15418/whyparallelism/#modern-parallel-hardware","title":"\ud83d\udda5\ufe0f Modern Parallel Hardware","text":""},{"location":"notes/CMU15418/whyparallelism/#apple-products","title":"\u25a0 Apple Products","text":"<ul> <li>Mac Pro: 12-core Intel Xeon E5. </li> <li>iPad Retina: 2 Swift cores. </li> </ul>"},{"location":"notes/CMU15418/whyparallelism/#supercomputers","title":"\u25a0 Supercomputers","text":"<ul> <li>Titan (#2 Supercomputer): 18,688 AMD CPUs + 18,688 NVIDIA GPUs. </li> </ul>"},{"location":"notes/CMU15418/whyparallelism/#course-themes","title":"\ud83e\udde9 Course Themes","text":"<ol> <li>Scaling Parallel Programs:    - Decomposition, work assignment, communication.  </li> <li>Hardware Efficiency:    - Performance vs. cost vs. power.  </li> <li>Post-2004 Shift:    - Maximize performance per Watt instead of raw speed.  </li> </ol>"},{"location":"notes/CMU15418/whyparallelism/#key-takeaways","title":"\ud83d\udea8 Key Takeaways","text":"<ul> <li>Single-thread performance growth is stagnant \u2192 Parallelism is essential.  </li> <li>Writing parallel code is challenging but unlocks immense computational power.  </li> <li>Efficiency matters: 2x speedup on 1010 processors is not impressive.  </li> </ul> <p>\ud83d\udce2 Welcome to 15-418! </p>"},{"location":"notes/MIT6.046/Convex%20Hull%26Median%20Finding/","title":"3 Convex Hull&Median Finding","text":""},{"location":"notes/MIT6.046/Convex%20Hull%26Median%20Finding/#lecture-2-divide-and-conquer","title":"Lecture 2: Divide and Conquer","text":"<p> \u7ea6 473 \u4e2a\u5b57  3 \u5f20\u56fe\u7247  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 2 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p>"},{"location":"notes/MIT6.046/Convex%20Hull%26Median%20Finding/#paradigm","title":"Paradigm","text":"<ul> <li>Given: A problem of size \\(n\\).  </li> <li>Divide it into subproblems of size \\(\\frac{n}{b}\\), where \\(a \\geq 1\\), \\(b &gt; 1\\).  </li> <li>Solve each subproblem recursively.  </li> <li>Combine solutions to form the overall solution.  </li> </ul> <p>Recurrence Relation: $$ T(n) = a T\\left(\\frac{n}{b}\\right) + [\\text{work for merge}] $$</p>"},{"location":"notes/MIT6.046/Convex%20Hull%26Median%20Finding/#convex-hull","title":"Convex Hull","text":""},{"location":"notes/MIT6.046/Convex%20Hull%26Median%20Finding/#problem-definition","title":"Problem Definition","text":"<ul> <li>Input: \\(n\\) points in the plane:   $$   S = \\left{ (x_i, y_i) \\mid i = 1, 2, \\ldots, n \\right}   $$  </li> <li>Assumptions: No two points share the same \\(x\\)- or \\(y\\)-coordinate; no three points are colinear.  </li> <li>Output: Convex Hull \\(\\text{CH}(S)\\), the smallest polygon containing all points in \\(S\\).  </li> </ul>"},{"location":"notes/MIT6.046/Convex%20Hull%26Median%20Finding/#brute-force-approach","title":"Brute Force Approach","text":"<ul> <li>Test each line segment to determine if it is an edge of the convex hull:  </li> <li>If all other points lie on one side of the segment, the segment is part of the convex hull.  </li> <li>Complexity: \\(O(n^3)\\) (testing \\(O(n^2)\\) edges with \\(O(n)\\) checks per edge).  </li> </ul>"},{"location":"notes/MIT6.046/Convex%20Hull%26Median%20Finding/#divide-and-conquer-approach","title":"Divide and Conquer Approach","text":"<ol> <li>Sort points by \\(x\\)-coordinate (\\(O(n \\log n)\\)).  </li> <li>Divide \\(S\\) into left half \\(A\\) and right half \\(B\\).  </li> <li>Recursively compute \\(\\text{CH}(A)\\) and \\(\\text{CH}(B)\\).  </li> <li>Merge the two convex hulls.  </li> </ol>"},{"location":"notes/MIT6.046/Convex%20Hull%26Median%20Finding/#merge-step","title":"Merge Step","text":"<ol> <li>Find Upper Tangent \\((a_i, b_j)\\) and Lower Tangent \\((a_k, b_m)\\).  </li> <li>Link \\(a_i \\rightarrow b_j\\), traverse down \\(B\\) to \\(b_m\\), link \\(b_m \\rightarrow a_k\\), and return to \\(a_i\\).  </li> </ol> <p>Example:  - Upper Tangent: \\((a_4, b_2)\\). - Lower Tangent: \\((a_3, b_3)\\). - Merged Hull: \\((a_4, b_2, b_3, a_3)\\).  </p>"},{"location":"notes/MIT6.046/Convex%20Hull%26Median%20Finding/#finding-tangents","title":"Finding Tangents","text":"<ul> <li>Upper Tangent: Maximizes \\(y(i, j)\\), where \\(y(i, j)\\) is the \\(y\\)-coordinate of the intersection between the vertical separating line \\(L\\) and segment \\((a_i, b_j)\\).  </li> <li>Algorithm:   1. Initialize \\(i = 1\\), \\(j = 1\\).   2. While \\(y(i, j+1) &gt; y(i, j)\\) or \\(y(i-1, j) &gt; y(i, j)\\):<ul> <li>If \\(y(i, j+1) &gt; y(i, j)\\): \\(j = j + 1 \\mod q\\).</li> <li>Else: \\(i = i - 1 \\mod p\\).   3. Return \\((a_i, b_j)\\).</li> </ul> </li> <li>Time Complexity:   $$   T(n) = 2 T\\left(\\frac{n}{2}\\right) + \\Theta(n) = \\Theta(n \\log n)   $$</li> </ul>"},{"location":"notes/MIT6.046/Convex%20Hull%26Median%20Finding/#median-finding","title":"Median Finding","text":""},{"location":"notes/MIT6.046/Convex%20Hull%26Median%20Finding/#problem-definition_1","title":"Problem Definition","text":"<ul> <li>Rank of \\(x\\): Number of elements \\(\\leq x\\).  </li> <li>Goal: Find element with rank \\(\\left\\lfloor\\frac{n+1}{2}\\right\\rfloor\\) (lower median) or \\(\\left\\lceil\\frac{n+1}{2}\\right\\rceil\\) (upper median).  </li> </ul>"},{"location":"notes/MIT6.046/Convex%20Hull%26Median%20Finding/#algorithm-select","title":"Algorithm: SELECT","text":"<ol> <li>Pick \\(x \\in S\\) cleverly (median of medians).  </li> <li>Partition \\(S\\) into \\(B = \\{y \\in S \\mid y &lt; x\\}\\) and \\(C = \\{y \\in S \\mid y &gt; x\\}\\).  </li> <li>Recurse on \\(B\\) or \\(C\\) based on \\(k = \\text{rank}(x)\\):    - If \\(k = i\\), return \\(x\\).    - If \\(k &gt; i\\), return \\(\\text{SELECT}(B, i)\\).    - If \\(k &lt; i\\), return \\(\\text{SELECT}(C, i - k)\\).  </li> </ol>"},{"location":"notes/MIT6.046/Convex%20Hull%26Median%20Finding/#median-of-medians","title":"Median of Medians","text":"<ol> <li>Arrange \\(S\\) into columns of size 5.  </li> <li>Sort each column (linear time).  </li> <li>Recursively compute the median of medians.  </li> </ol> <p>Recurrence: $$ T(n) =  \\begin{cases} O(1), &amp; \\text{for } n \\leq 140, \\ T\\left(\\left\\lceil\\frac{n}{5}\\right\\rceil\\right) + T\\left(\\frac{7n}{10} + 6\\right) + \\Theta(n), &amp; \\text{for } n &gt; 140. \\end{cases} $$</p> <p>Proof Sketch: $$ T(n) \\leq cn \\quad \\text{(by induction, using } \\frac{n}{5} + \\frac{7n}{10} &lt; n\\text{)}. $$</p>"},{"location":"notes/MIT6.046/Convex%20Hull%26Median%20Finding/#appendix","title":"Appendix","text":""},{"location":"notes/MIT6.046/Convex%20Hull%26Median%20Finding/#example-tangent-identification","title":"Example: Tangent Identification","text":"<p> - Upper Tangent: \\(a_3, b_1\\). - Lower Tangent: \\(a_1, b_3\\). - Note: Tangents need not involve the highest/lowest points.  </p>"},{"location":"notes/MIT6.046/FFT/","title":"2 FFT","text":""},{"location":"notes/MIT6.046/FFT/#polynomial-operations-and-representation","title":"Polynomial Operations and Representation","text":"<p> \u7ea6 496 \u4e2a\u5b57  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 2 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p> <p>A polynomial \\(A(x)\\) can be written in the following forms: $$ \\begin{aligned} A(x) &amp;= a_0 + a_1x + a_2x^2 + \\cdots + a_{n-1}x^{n-1}   \\\\ &amp;= \\sum_{k=0}^{n-1} a_k x^k   \\\\ &amp;= \\left\\langle a_0, a_1, a_2, \\ldots, a_{n-1} \\right\\rangle \\quad \\text{(coefficient vector)} \\end{aligned} $$</p>"},{"location":"notes/MIT6.046/FFT/#the-degree-of-a-is-n-1","title":"The degree of \\(A\\) is \\(n-1\\)","text":""},{"location":"notes/MIT6.046/FFT/#operations-on-polynomials","title":"Operations on Polynomials","text":"<ol> <li> <p>Evaluation: Given \\( A(x) \\) and \\( x_0 \\), compute \\( A(x_0) \\).    - Horner's Rule:      $$      A(x) = a_0 + x\\left(a_1 + x\\left(a_2 + \\cdots + x\\left(a_{n-1}\\right)\\cdots\\right)\\right)      $$ Time: \\( O(n) \\).</p> </li> <li> <p>Addition: \\( C(x) = A(x) + B(x) \\).    - \\( c_k = a_k + b_k \\). Time: \\( O(n) \\).</p> </li> <li> <p>Multiplication: \\( C(x) = A(x) \\cdot B(x) \\).    - \\( c_k = \\sum_{j=0}^k a_j b_{k-j} \\).    - Naive Time: \\( O(n^2) \\).    - FFT Time: \\( O(n \\log n) \\).</p> </li> </ol>"},{"location":"notes/MIT6.046/FFT/#representations-of-polynomials","title":"Representations of Polynomials","text":"Representation Evaluation Addition Multiplication Coefficients \\( O(n) \\) \\( O(n) \\) \\( O(n^2) \\) Roots \\( O(n) \\) Impossible \\( O(n) \\) Samples \\( O(n^2) \\) \\( O(n) \\) \\( O(n) \\) <p>Key Insight: Convert between coefficients and samples in \\( O(n \\log n) \\) time using FFT.</p>"},{"location":"notes/MIT6.046/FFT/#divide-and-conquer-algorithm-for-polynomial-multiplication","title":"Divide and Conquer Algorithm for Polynomial Multiplication","text":"<ol> <li> <p>Divide: Split \\( A(x) \\) into even and odd coefficients:    $$    \\begin{aligned}    A_{\\text{even}}(x) &amp;= \\sum_{k=0}^{\\lceil n/2 \\rceil -1} a_{2k} x^k, \\\\    A_{\\text{odd}}(x) &amp;= \\sum_{k=0}^{\\lfloor n/2 \\rfloor -1} a_{2k+1} x^k.    \\end{aligned}    $$</p> </li> <li> <p>Conquer: Recursively compute \\( A_{\\text{even}}(y) \\) and \\( A_{\\text{odd}}(y) \\) for \\( y \\in X^2 \\).  </p> </li> <li> <p>Combine:    $$    A(x) = A_{\\text{even}}(x^2) + x \\cdot A_{\\text{odd}}(x^2)    $$</p> </li> </ol> <p>Recurrence: $$ T(n) = 2T\\left(\\frac{n}{2}\\right) + O(n) = O(n \\log n) $$</p>"},{"location":"notes/MIT6.046/FFT/#roots-of-unity","title":"Roots of Unity","text":"<p>Definition: The \\(n\\) -th roots of unity are \\(x\\) such that \\(x^n = 1\\). They are spaced uniformly on the unit circle in the complex plane: $$ x_k = e^{i \\tau k / n}, \\quad k = 0, 1, \\ldots, n - 1 \\quad (\\tau = 2\\pi) $$</p> <p>Collapsing Property: For \\(n = 2^\\ell\\), squaring the roots reduces the problem size by half: $$ \\left(e^{i \\tau k / n}\\right)^2 = e^{i \\tau k / (n/2)} $$</p>"},{"location":"notes/MIT6.046/FFT/#fft-and-ifft","title":"FFT and IFFT","text":""},{"location":"notes/MIT6.046/FFT/#fast-fourier-transform-fft","title":"Fast Fourier Transform (FFT)","text":"<ul> <li>DFT: Convert coefficients to samples using roots of unity:  </li> </ul> \\[ A^* = V \\cdot A \\quad \\text{where } V_{jk} = e^{i \\tau jk / n} \\] <ul> <li>Time: \\(O(n \\log n)\\)</li> </ul>"},{"location":"notes/MIT6.046/FFT/#inverse-fft-ifft","title":"Inverse FFT (IFFT)","text":"<ul> <li>IDFT: Convert samples back to coefficients:  </li> </ul> \\[ A = \\frac{1}{n} \\bar{V} \\cdot A^* \\] <ul> <li>Time: \\(O(n \\log n)\\)</li> </ul>"},{"location":"notes/MIT6.046/FFT/#polynomial-multiplication-via-fft","title":"Polynomial Multiplication via FFT","text":"<p>Steps:  </p> <ol> <li>Compute \\(A^*= \\text{FFT}(A)\\) and \\(B^* = \\text{FFT}(B)\\).  </li> <li>Multiply samples: \\(C^*= A^* \\cdot B^*\\).  </li> <li>Convert back: \\(C = \\text{IFFT}(C^*)\\).  </li> </ol> <p>Example:  </p> <ul> <li>Let \\(A(x) = 1 + 2x\\) and \\(B(x) = 3 + 4x\\).  </li> <li>FFT:  </li> <li>\\(A^*= [3, -1]\\), \\(B^* = [7, -1]\\).  </li> <li>Multiply: \\(C^* = [21, 1]\\).  </li> <li>IFFT: \\(C(x) = 3 + 10x + 8x^2\\).  </li> </ul> <p>Analysis:  </p> <ul> <li>Naive multiplication: \\(O(n^2) = O(4)\\).  </li> <li>FFT - based: \\(O(n \\log n) = O(2 \\log 2)\\).  </li> </ul>"},{"location":"notes/MIT6.046/FFT/#applications-of-fft","title":"Applications of FFT","text":"<ul> <li>Signal Processing: Filtering, compression (MP3), spectral analysis.  </li> <li>Algorithm Design: Convolution, large integer multiplication.  </li> </ul>"},{"location":"notes/MIT6.046/Interval%20Scheduling/","title":"1 Interval Scheduling","text":""},{"location":"notes/MIT6.046/Interval%20Scheduling/#course-overview","title":"Course Overview","text":"<p> \u7ea6 403 \u4e2a\u5b57  4 \u5f20\u56fe\u7247  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 2 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p> <ul> <li>Modules Covered:   1. Divide and Conquer (FFT, Randomized algorithms)   2. Optimization (greedy, dynamic programming)   3. Network Flow   4. Intractibility and coping strategies   5. Linear Programming   6. Sublinear and Approximation Algorithms   7. Advanced Topics</li> </ul>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#key-complexity-classes","title":"Key Complexity Classes","text":"<ul> <li>P: Solvable in polynomial time (e.g., shortest paths in \\(O(V^2)\\)).</li> <li>NP: Verifiable in polynomial time (e.g., Hamiltonian Cycle detection is NP-complete, but verification is easy).</li> <li>NP-Complete: A problem in NP that is as hard as any problem in NP. Solving one in polynomial time would solve all NP problems.</li> </ul>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#interval-scheduling","title":"Interval Scheduling","text":"<p>Problem: Select a maximum subset of non-overlapping requests. Each request has: - Start time \\(s(i)\\) - Finish time \\(f(i)\\) (with \\(s(i) &lt; f(i)\\))  </p> <p>Compatibility: Two requests \\(i\\) and \\(j\\) are compatible if: \\(\\(f(i) \\leq s(j) \\quad \\text{or} \\quad f(j) \\leq s(i)\\)\\)</p> <p>Example:  Requests 2 &amp; 3 are compatible; 4, 5, 6 are compatible; 2 &amp; 4 are not.</p>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#greedy-algorithms-for-interval-scheduling","title":"Greedy Algorithms for Interval Scheduling","text":"<p>Claim: Greedy algorithm with earliest finish time yields an optimal solution.  </p>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#possible-greedy-rules","title":"Possible Greedy Rules:","text":"<ol> <li> <p>Earliest Start Time Fails for overlapping long intervals.</p> </li> <li> <p>Smallest Interval Fails if small intervals block larger compatible ones.</p> </li> <li> <p>Fewest Conflicts Computationally expensive to track conflicts.</p> </li> <li> <p>Earliest Finish Time Optimal.</p> </li> </ol>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#proof-of-optimality-for-earliest-finish-time","title":"Proof of Optimality for Earliest Finish Time","text":"<p>Inductive Proof: - Base Case: \\(k^* = 1\\) \u2013 trivial. - Inductive Step: Assume optimality holds for \\(k^*\\). For \\(k^* + 1\\):   - Let \\(S^*\\) be the optimal schedule. Greedy picks \\(i_1\\) with \\(f(i_1) \\leq f(j_1)\\).   - Construct \\(S^{**} = \\{i_1, j_2, \\ldots, j_{k^*+1}\\}\\), which is also optimal.   - Residual problem \\(L'\\) (intervals after \\(f(i_1)\\)) has optimal size \\(k^*\\). By induction, greedy on \\(L'\\) gives \\(k^*\\) intervals.   - Total schedule size: \\(1 + k^* = k^* + 1\\).  </p>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#weighted-interval-scheduling","title":"Weighted Interval Scheduling","text":"<p>Problem: Maximize total weight of non-overlapping requests. - Greedy fails due to weights. - Dynamic Programming Approach:   Define \\(R^x = \\{j \\mid s(j) \\geq x\\}\\). Recurrence: \\(\\(\\text{opt}(R) = \\max_{1 \\leq i \\leq n} \\left( w(i) + \\text{opt}(R^{f(i)}) \\right)\\)\\)   - Time: \\(O(n^2)\\) (can be optimized to \\(O(n \\log n)\\)).  </p>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#non-identical-machines","title":"Non-Identical Machines","text":"<p>Problem: Schedule jobs on \\(m\\) machines where each job \\(i\\) can only run on a subset \\(Q(i) \\subseteq \\{T_1, \\ldots, T_m\\}\\). - Complexity:   - Decision version (\"Can \\(k \\leq n\\) jobs be scheduled?\") is NP-Complete.   - Optimization version (\"Maximize scheduled jobs\") is NP-Hard.  </p>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#coping-with-intractability","title":"Coping with Intractability","text":"<ol> <li>Approximation Algorithms: Guarantee near-optimal solutions in polynomial time.  </li> <li>Pruning Heuristics: Reduce search space for practical instances.  </li> <li>Greedy Heuristics: No guarantees but perform well empirically.  </li> </ol>"},{"location":"notes/MIT6.046/van%20Emde%20Boas%20Trees/","title":"4 van Emde Boas Trees","text":""},{"location":"notes/MIT6.046/van%20Emde%20Boas%20Trees/#lecture-4-divide-and-conquer-van-emde-boas-trees","title":"Lecture 4: Divide and Conquer: van Emde Boas Trees","text":"<p> \u7ea6 780 \u4e2a\u5b57  1 \u5f20\u56fe\u7247  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 4 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p>"},{"location":"notes/MIT6.046/van%20Emde%20Boas%20Trees/#series-of-improved-data-structures","title":"Series of Improved Data Structures","text":"<ul> <li>Insert, Successor</li> <li>Delete</li> <li>Space</li> </ul> <p>This lecture is based on personal communication with Michael Bender, 2001.</p>"},{"location":"notes/MIT6.046/van%20Emde%20Boas%20Trees/#goal","title":"Goal","text":"<p>We want to maintain <code>n</code> elements in the range <code>{0, 1, 2, ..., u-1}</code> and perform Insert, Delete, and Successor operations in <code>O(log log u)</code> time.</p> <ul> <li>If <code>n = n^O(1)</code> or <code>n^(log n)^O(1)</code>, then we have <code>O(log log n)</code> time operations.</li> <li>Exponentially faster than Balanced Binary Search Trees.</li> <li>Cooler queries than hashing.</li> <li>Application: Network Routing Tables.</li> </ul> \\[ u = \\text{Range of IP Addresses} \\rightarrow \\text{port to send} \\quad (u = 2^{32} \\text{ in IPv4)} \\] <p>Where might the <code>O(log log u)</code> bound arise? - Binary search over <code>O(log u)</code> elements. - Recurrences:</p> \\[ \\begin{align*} &amp; T(\\log u) = T\\left(\\frac{\\log u}{2}\\right) + O(1) \\\\ &amp; T(u) = T(\\sqrt{u}) + O(1) \\end{align*} \\]"},{"location":"notes/MIT6.046/van%20Emde%20Boas%20Trees/#improvements","title":"Improvements","text":"<p>We will develop the van Emde Boas data structure by a series of improvements on a very simple data structure.</p>"},{"location":"notes/MIT6.046/van%20Emde%20Boas%20Trees/#bit-vector","title":"Bit Vector","text":"<p>We maintain a vector <code>V</code> of size <code>u</code> such that <code>V[x] = 1</code> if and only if <code>x</code> is in the set. Now, inserts and deletes can be performed by just flipping the corresponding bit in the vector. However, successor/predecessor requires us to traverse through the vector to find the next 1-bit.</p> <ul> <li>Insert/Delete: <code>O(1)</code></li> <li>Successor/Predecessor: <code>O(u)</code></li> </ul> Text Only<pre><code>| 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 1 |\n</code></pre> <p>Figure 1: Bit vector for <code>u = 16</code>. The current set is <code>{1, 9, 10, 15}</code>.</p>"},{"location":"notes/MIT6.046/van%20Emde%20Boas%20Trees/#split-universe-into-clusters","title":"Split Universe into Clusters","text":"<p>We can improve performance by splitting up the range <code>{0, 1, 2, ..., u-1}</code> into <code>sqrt(u)</code> clusters of size <code>sqrt(u)</code>. If <code>x = i * sqrt(u) + j</code>, then <code>V[x] = V.cluster[i][j]</code>.</p> \\[ \\begin{align*} &amp; \\text{low}(x) = x \\mod \\sqrt{u} = j \\\\ &amp; \\text{high}(x) = \\left\\lfloor \\frac{x}{\\sqrt{u}} \\right\\rfloor = i \\\\ &amp; \\text{index}(i, j) = i * \\sqrt{u} + j \\end{align*} \\] <p></p> <ul> <li>Insert:</li> <li>Set <code>V.cluster[high(x)][low(x)] = 1</code> <code>O(1)</code></li> <li>Mark cluster <code>high(x)</code> as non-empty <code>O(1)</code></li> <li>Successor:</li> <li>Look within cluster <code>high(x)</code> <code>O(sqrt(u))</code></li> <li>Else, find next non-empty cluster <code>i</code></li> <li>Find minimum entry <code>j</code> in that cluster <code>O(sqrt(u))</code></li> <li>Return <code>index(i, j)</code> Total <code>= O(sqrt(u))</code></li> </ul>"},{"location":"notes/MIT6.046/van%20Emde%20Boas%20Trees/#recurse","title":"Recurse","text":"<p>The three operations in Successor are also Successor calls to vectors of size <code>sqrt(u)</code>. We can use recursion to speed things up.</p> <ul> <li><code>V.cluster[i]</code> is a size <code>-sqrt(u)</code> van Emde Boas structure <code>(\u2200 0 \u2264 i &lt; sqrt(u))</code></li> <li><code>V.summary</code> is a size <code>-sqrt(u)</code> van Emde Boas structure</li> <li><code>V.summary[i]</code> indicates whether <code>V.cluster[i]</code> is nonempty</li> </ul> Text Only<pre><code>INSERT(V, x)\n1 Insert(V.cluster[high(x)], low(x))\n2 Insert(V.summary, high(x))\n</code></pre> <p>So, we get the recurrence:</p> \\[ \\begin{align*} T(u) &amp;= 2 T(\\sqrt{u}) + O(1) \\\\ T'(\\log u) &amp;= 2 T'\\left(\\frac{\\log u}{2}\\right) + O(1) \\\\ \\Longrightarrow T(u) &amp;= T'(\\log u) = O(\\log u) \\end{align*} \\] Text Only<pre><code>SUCCESSOR(V, x)\n1 i = high(x)\n2 j = Successor(V.cluster[i], j)\n3 if j == \u221e\n4   i = Successor(V.summary, i)\n5   j = Successor(V.cluster[i], -\u221e)\n6 return index(i, j)\n</code></pre> \\[ \\begin{align*} T(u) &amp;= 3 T(\\sqrt{u}) + O(1) \\\\ T'(\\log u) &amp;= 3 T'\\left(\\frac{\\log u}{2}\\right) + O(1) \\\\ \\Longrightarrow T(u) &amp;= T'(\\log u) = O((\\log u)^{\\log 3}) \\approx O((\\log u)^{1.585}) \\end{align*} \\] <p>To obtain the <code>O(log log u)</code> running time, we need to reduce the number of recursions to one.</p>"},{"location":"notes/MIT6.046/van%20Emde%20Boas%20Trees/#maintain-min-and-max","title":"Maintain Min and Max","text":"<p>We store the minimum and maximum entry in each structure. This gives an <code>O(1)</code> time overhead for each Insert operation.</p> Text Only<pre><code>SUCCESSOR(V, x)\n1 i = high(x)\n2 if low(x) &lt; V.cluster[i].max\n3   j = Successor(V.cluster[i], low(x))\n4 else\n5   i = Successor(V.summary, high(x))\n6   j = V.cluster[i].min\n7 return index(i, j)\n</code></pre> <p>$$ \\begin{align} T(u) &amp;= T(\\sqrt{u}) + O(1) \\ \\Longrightarrow T(u) &amp;= O(\\log log u) \\end{align} $$ </p>Text Only<pre><code>## Don't store Min recursively\nThe Successor call now needs to check for the min separately.\n</code></pre> if x &lt; V.min: return V.min (1) Text Only<pre><code>INSERT(V, x)\n1 if V.min == None\n2   V.min = V.max = x (O(1) time)\n3 return\n4 if x &lt; V.min\n5   swap(x \u2194 V.min)\n6 if x &gt; V.max\n7   V.max = x\n8 if V.cluster[high(x)] == None\n9   Insert(V.summary, high(x)) First Call\n10  Insert(V.cluster[high(x)], low(x)) Second Call\n</code></pre> <p>If the first call is executed, the second call only takes <code>O(1)</code> time. So</p> \\[ \\begin{align*} T(u) &amp;= T(\\sqrt{u}) + O(1) \\\\ \\Longrightarrow T(u) &amp;= O(\\log log u) \\end{align*} \\] Text Only<pre><code>DELETE(V, x)\n1 if x == V.min Find new min\n2   i = V.summary.min\n3   if i == None\n4     V.min = V.max = None (O(1) time)\n5     return\n6   V.min = index(i, V.cluster[i].min) Unstore new min\n7 Delete(V.cluster[high(x)], low(x)) First Call\n8 if V.cluster[high(x)].min == None\n9   Delete(V.summary, high(x)) Second Call\n10 Now we update V.max\n11 if x == V.max\n12   if V.summary.max == None\n13   else\n14     i = V.summary.max\n15     V.max = index(i, V.cluster[i].max)\n</code></pre> <p>If the second call is executed, the first call only takes <code>O(1)</code> time. So</p> \\[ \\begin{align*} T(u) &amp;= T(\\sqrt{u}) + O(1) \\\\ \\Longrightarrow T(u) &amp;= O(\\log log u) \\end{align*} \\]"},{"location":"notes/MIT6.046/van%20Emde%20Boas%20Trees/#lower-bound-patrascu-thorup-2007","title":"Lower Bound [Patrascu &amp; Thorup 2007]","text":"<p>Even for static queries (no Insert/Delete) - <code>\u03a9(log log u)</code> time per query for <code>u = n^(log n)^O(1)</code> - <code>O(n * poly(log n))</code> space</p>"},{"location":"notes/MIT6.046/van%20Emde%20Boas%20Trees/#space-improvements","title":"Space Improvements","text":"<p>We can improve from <code>\u0398(u)</code> to <code>O(n log log u)</code>. - Only create nonempty clusters - If V.min becomes None, deallocate V - Store V.cluster as a hashtable of nonempty clusters - Each insert may create a new structure <code>\u0398(log log u)</code> times (each empty insert) - Can actually happen [Vladimir \u010cun\u00e1t] - Charge pointer to structure (and associated hash table entry) to the structure This gives us <code>O(n log log u)</code> space (but randomized).</p>"},{"location":"notes/MIT6.046/van%20Emde%20Boas%20Trees/#indirection","title":"Indirection","text":"<p>We can further reduce to <code>O(n)</code> space. - Store vEB structure with <code>n = O(log log u)</code> using BST or even an array <code>\u27f9 O(log log n)</code> time once in base case - We use <code>O(n / log log u)</code> such structures (disjoint)</p> \\[ \\Longrightarrow O\\left(\\frac{n}{\\log \\log u} \\cdot \\log \\log u\\right) = O(n) \\text{ space for small} \\] <ul> <li>Larger structures \"store\" pointers to them</li> </ul> \\[ \\left(\\frac{n}{\\log \\log u} \\cdot \\log \\log u\\right) = O(n) \\text{ space for large} \\]"},{"location":"notes/UCB-CS61c/1-intro/","title":"Intro","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/1-intro/#intro","title":"Intro","text":"<p> \u7ea6 154 \u4e2a\u5b57  1 \u5f20\u56fe\u7247  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 1 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p> <p>title: Intro math: false tags:   - CS61C</p>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/1-intro/#great-ideas","title":"Great Ideas","text":"<ol> <li>Abstraction: Levels of Representation / Interpretation </li> <li>Moore's Law: Designing through trends</li> <li>Principle of Locality: Memory Hierarchy</li> <li>Parallelism &amp; Amdahl's law</li> <li>Dependability via Redundancy</li> </ol>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/1-intro/#number-representations","title":"Number Representations","text":"<ul> <li>Bit: 0/1</li> <li>Byte: 8 bits</li> <li>Most Significant Bit (MSB)</li> <li>Least Significant Bit (LSB)</li> <li>One's Complement: <code>-x=~x</code><ul> <li>Neg: \\([-(2^{n-1}-1),-0]\\)</li> <li>Pos: \\([0, 2^{n-1}-1]\\)</li> </ul> </li> <li>Two's Complement: <code>-x=~x+1</code><ul> <li>Neg: \\([-2^{n-1},-1]\\)</li> <li>Pos: \\([0, 2^{n-1}-1]\\)</li> </ul> </li> <li>Bias encoding: \u4f8b\u5982\u60f3\u8981\u5229\u7528 4 \u4f4d bits \u4ee3\u8868 \\([-3,12]\\)\uff0c\u53ea\u9700\u53d6 bias \u4e3a \\(-3\\)\uff0c\u5229\u7528 \\([0,15]\\) \u6765\u8868\u793a<ul> <li>\u5bf9 two's complement\uff0cbias \u4e3a \\(N=-2^{n-1}+1\\)\uff0c\u4e0d\u8fc7 \\(-2^{n-1} - N=-1\\)\uff0c\u800c\u4e0d\u662f \\(0\\) </li> <li>\u8fd9\u662f\u56e0\u4e3a\u5728 floating representations \u4e2d\uff0c\u5168\u4e3a \\(1\\) \u7684\u6570\u6709\u7279\u6b8a\u7528\u9014</li> <li>\u4f8b\u5982\uff1a <code>0b1010</code> \u7684 bias \u4e3a \\(-2^{4-1}+1=-7\\), \u8fd9\u4e2a\u6570\u4e3a \\(10-(-7)=3\\)</li> </ul> </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20memory%20management/","title":"4 C memory management","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#c-memory-management-usage-comprehensive-notes","title":"\ud83e\udde0 C Memory Management &amp; Usage - Comprehensive Notes","text":"<p> \u7ea6 411 \u4e2a\u5b57  38 \u884c\u4ee3\u7801  4 \u5f20\u56fe\u7247  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 3 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#table-of-contents","title":"\ud83d\udcda Table of Contents","text":"<ol> <li>C Memory Layout</li> <li>Addressing &amp; Endianness</li> <li>Dynamic Memory Allocation</li> <li>Common Memory Problems</li> <li>Linked List Example</li> <li>Memory Fragmentation &amp; K&amp;R Algorithm</li> <li>Debugging Tools</li> </ol>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#c-memory-layout","title":"\ud83d\uddfa\ufe0f C Memory Layout","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#program-address-space","title":"Program Address Space","text":"<ul> <li>4 Regions:   1. Stack \ud83d\udce5  <ul> <li>Stores local variables (declared inside functions).  </li> <li>Grows downward.  </li> <li>Freed when function returns.  </li> <li>Example: <code>int x = 5;</code> inside <code>main()</code>.</li> </ul> </li> </ul> <ol> <li> <p>Heap \ud83e\uddf1  </p> <ul> <li>Dynamically allocated via <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code>.  </li> <li>Grows upward.  </li> <li>Must be explicitly freed with <code>free()</code>.  </li> <li>Example: <code>int *arr = malloc(10 * sizeof(int));</code>.</li> </ul> </li> <li> <p>Static Data \ud83c\udf10  </p> <ul> <li>Stores global/static variables and string literals.  </li> <li>Does not grow/shrink.  </li> <li>Example: <code>char *str = \"hello\";</code> (string literal in static data).  </li> <li>\u26a0\ufe0f <code>char str[] = \"hello\";</code> stores the array on the stack!</li> </ul> </li> <li> <p>Code \ud83d\udcdc  </p> <ul> <li>Contains compiled machine code.  </li> <li>Read-only and immutable.</li> </ul> </li> </ol>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#addressing-endianness","title":"\ud83d\udd22 Addressing &amp; Endianness","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#key-concepts","title":"Key Concepts","text":"<ul> <li>Byte-Addressed Machines: Each address points to a unique byte.  </li> <li>Word-Addressed Machines: Each address points to a word (group of bytes).  </li> <li>Endianness: Order of bytes in multi-byte data types.  </li> </ul>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#types-of-endianness","title":"Types of Endianness","text":"<ol> <li>Big Endian \ud83d\udc18    - Most significant byte at lowest address.    - Example: <code>0x12345678</code> stored as <code>12 34 56 78</code>.  </li> <li>Little Endian \ud83d\udc2d    - Least significant byte at lowest address.    - Example: <code>0x12345678</code> stored as <code>78 56 34 12</code>.  </li> </ol>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#example-integer-28-0x0000001c","title":"Example: Integer <code>28</code> (0x0000001C)","text":"<ul> <li>Big Endian: <code>00 00 00 1C</code> </li> <li>Little Endian: <code>1C 00 00 00</code> </li> </ul>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#dynamic-memory-allocation","title":"\ud83d\udca5 Dynamic Memory Allocation","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#functions","title":"Functions","text":"<ol> <li><code>malloc(n)</code>    - Allocates <code>n</code> bytes of uninitialized memory.    - Example: C<pre><code>int *arr = (int*)malloc(5 * sizeof(int)); // Allocate space for 5 integers\n</code></pre></li> <li><code>calloc(n, size)</code>    - Allocates <code>n * size</code> bytes initialized to zero.    - Example: C<pre><code>int *arr = (int*)calloc(5, sizeof(int)); // [0, 0, 0, 0, 0]\n</code></pre></li> <li><code>realloc(ptr, new_size)</code>    - Resizes existing memory block.    - May move the block to a new address.    - Example: C<pre><code>arr = realloc(arr, 10 * sizeof(int)); // Expand to 10 integers\n</code></pre></li> <li><code>free(ptr)</code>    - Releases memory.    - \u26a0\ufe0f Never free:  <ul> <li>Stack variables.  </li> <li>Already freed memory.  </li> <li>Middle of a block (e.g., <code>free(arr + 1)</code>).</li> </ul> </li> </ol>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#common-memory-problems","title":"\ud83d\udea8 Common Memory Problems","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#1-using-uninitialized-values","title":"1. Using Uninitialized Values","text":"C<pre><code>int *p;\nprintf(\"%d\", *p); // Undefined behavior! p points to garbage.\n</code></pre>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#2-using-memory-you-dont-own","title":"2. Using Memory You Don\u2019t Own","text":"<ul> <li>Example 1: Returning a stack-allocated array. C<pre><code>char* func() {\n    char arr;\n    return arr; // \u274c arr is on the stack; invalid after function returns.\n}\n</code></pre></li> <li>Example 2: Buffer overflow. C<pre><code>char buf;\nstrcpy(buf, \"This is too long!\"); // Writes beyond buf\n</code></pre></li> </ul>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#3-freeing-invalid-memory","title":"3. Freeing Invalid Memory","text":"<ul> <li>Double Free: C<pre><code>int *p = malloc(4);\nfree(p);\nfree(p); // \u274c p already freed.\n</code></pre></li> <li>Freeing Stack Variable: C<pre><code>int x = 5;\nfree(&amp;x); // \u274c x is on the stack.\n</code></pre></li> </ul>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#4-memory-leaks","title":"4. Memory Leaks","text":"<ul> <li>Example: Overwriting a pointer before freeing. C<pre><code>int *p = malloc(4);\np = malloc(8); // \u274c Original 4 bytes are now unreachable.\n</code></pre></li> </ul>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#linked-list-example","title":"\ud83d\udd17 Linked List Example","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#node-structure","title":"Node Structure","text":"C<pre><code>struct Node {\n    char *value;\n    struct Node *next;\n};\n</code></pre>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#adding-a-node","title":"Adding a Node","text":"C<pre><code>struct Node* addNode(char *s, struct Node *list) {\n    struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode-&gt;value = (char*)malloc(strlen(s) + 1); // +1 for '\\0'\n    strcpy(newNode-&gt;value, s);\n    newNode-&gt;next = list;\n    return newNode;\n}\n</code></pre>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#freeing-a-node","title":"Freeing a Node","text":"C<pre><code>void freeList(struct Node *list) {\n    while (list != NULL) {\n        struct Node *temp = list;\n        list = list-&gt;next;\n        free(temp-&gt;value); // Free the string\n        free(temp);        // Free the node\n    }\n}\n</code></pre>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#visualization","title":"Visualization","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#memory-fragmentation-kr-algorithm","title":"\ud83e\udde9 Memory Fragmentation &amp; K&amp;R Algorithm","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#fragmentation-example","title":"Fragmentation Example","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#kr-allocation-strategy","title":"K&amp;R Allocation Strategy","text":"<ul> <li>Free List: Linked list of free memory blocks.  </li> <li>Merging Adjacent Blocks: <code>free()</code> combines adjacent free blocks.  </li> <li>Allocation Policies:  </li> <li>First Fit: Use the first block that fits.  </li> <li>Best Fit: Use the smallest block that fits.  </li> <li>Next Fit: Resume search from last position.</li> </ul>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#debugging-tools","title":"\ud83d\udee0\ufe0f Debugging Tools","text":"<ul> <li>Valgrind \ud83e\uddea: Detects memory leaks, invalid accesses, and more. Bash<pre><code>valgrind --leak-check=full ./your_program\n</code></pre></li> <li>Example Output: Text Only<pre><code>==12345== Invalid write of size 4\n==12345==    at 0x400ABC: main (example.c:10)\n</code></pre></li> </ul>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#summary","title":"\ud83d\udccc Summary","text":"<ul> <li>Stack: Local variables, LIFO.  </li> <li>Heap: Dynamic, manually managed.  </li> <li>Static Data: Globals &amp; literals.  </li> <li>Code: Immutable.  </li> <li>Common Pitfalls: Leaks, invalid accesses, uninitialized values.  </li> <li>Golden Rule: Always pair <code>malloc()</code> with <code>free()</code>! \ud83d\uded1</li> </ul>"},{"location":"notes/UCB-CS61c/C%20pointers/","title":"C pointers","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#cs61c-lecture-notes-introduction-to-c-pointers","title":"\ud83d\udcda CS61C Lecture Notes: Introduction to C &amp; Pointers","text":"<p> \u7ea6 282 \u4e2a\u5b57  34 \u884c\u4ee3\u7801  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 2 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p> <p>Instructor: Stephan Kaminsky | Date: Jun 2019  </p>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#key-concepts-in-c-programming","title":"\ud83d\udccc Key Concepts in C Programming","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#1-compilation-in-c","title":"1. Compilation in C","text":"<ul> <li>Compiled Language: Converts C code directly to machine-specific instructions (0s and 1s).  </li> <li>\ud83d\ude80 Advantages: Faster execution than Java/Python (no bytecode/JVM).  </li> <li>\u26a0\ufe0f Disadvantages: Platform-dependent executables; slower edit-compile-run cycle.  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#2-variable-types-declarations","title":"2. Variable Types &amp; Declarations","text":"<ul> <li>Typed Variables: Must declare type before use.  </li> <li>Example: C<pre><code>int x = 5;          // Integer\nfloat y = 1.618;    // Floating point\nchar z = 'A';       // Character\n</code></pre></li> <li>Type Sizes: Machine-dependent (e.g., <code>int</code> = 4/8 bytes).  </li> <li>Special Keywords: <code>short</code>, <code>long</code>, <code>unsigned</code>.  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#3-characters-ascii","title":"3. Characters &amp; ASCII","text":"<ul> <li>ASCII Encoding: Characters stored as numbers (e.g., <code>'a'</code> = 97). C<pre><code>char c = 'a';     // Same as char c = 97;\n</code></pre></li> <li>Size: 1 byte (8 bits).  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#4-type-casting","title":"4. Type Casting","text":"<ul> <li>Weak Typing: Explicitly cast between types.  </li> <li>Example: C<pre><code>int i = -1;\nif ((unsigned int)i &lt; 0) { ... }  // False\n</code></pre></li> <li>\u26a0\ufe0f Caution: Risky casts (e.g., casting structs to integers).  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#5-functions","title":"5. Functions","text":"<ul> <li>Prototypes &amp; Definitions: C<pre><code>int add(int a, int b);   // Prototype\nint add(int a, int b) { return a + b; }  // Definition\n</code></pre></li> <li>Return Types: Must declare return type (<code>void</code> for no return).  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#6-structs-unions","title":"6. Structs &amp; Unions","text":"<ul> <li>Structs: Group related variables. C<pre><code>typedef struct {\n  int length;\n  int year;\n} Song;\nSong s = {213, 1994}; \n</code></pre></li> <li>Unions: Overlapping memory for different types. C<pre><code>union Data {\n  int i;\n  float f;\n};\n</code></pre></li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#example-struct-padding","title":"\ud83e\uddee Example: Struct Padding","text":"C<pre><code>struct foo {\n  int a;     // 4 bytes\n  char b;    // 1 byte (+3 padding)\n  struct foo* c;  // 4 bytes\n};  \n// Total size = 12 bytes (32-bit architecture)\n</code></pre>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#c-vs-java-comparison","title":"\ud83d\udcca C vs Java Comparison","text":"Feature C Java Language Type Function-Oriented Object-Oriented Memory Management Manual (<code>malloc</code>, <code>free</code>) Automatic (Garbage Collection) Hello World <code>printf(\"Hello\\n\");</code> <code>System.out.println(...);</code>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#pointers-address-vs-value","title":"\ud83c\udfaf Pointers: Address vs Value","text":"<ul> <li>Pointer Syntax: C<pre><code>int y = 5;\nint *p = &amp;y;   // p stores address of y\nint z = *p;    // z = value at address p (5)\n</code></pre></li> <li>Pointer Types:  </li> <li><code>int*</code>, <code>char*</code>, <code>void*</code> (generic pointer).  </li> <li>\u26a0\ufe0f Dangling Pointers: Uninitialized pointers \u2192 undefined behavior!  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#example-pointer-parameter-passing","title":"\ud83d\udd0d Example: Pointer Parameter Passing","text":"C<pre><code>void addOne(int *p) { (*p)++; }  \nint main() {\n  int y = 3;\n  addOne(&amp;y);    // y becomes 4\n  return 0;\n}\n</code></pre>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#quiz-4-bit-number-representations","title":"\u2753 Quiz: 4-Bit Number Representations","text":"<p>Given <code>x = 0b1010</code> (4 bits), which value does NOT represent <code>x</code>?  </p> <p>Options: (A) -4 \u2003(B) -6\u2003(C) 10\u2003(D) -2  </p> <p>Analysis: - Unsigned: \\(2^3 + 2^1 = 10\\) \u2714\ufe0f (C) - Sign &amp; Magnitude: \\(-2^1 = -2\\) \u2714\ufe0f (D) - Biased (Bias=7): \\(10 - 7 = 3\\) \u2192 Not an option. - Two\u2019s Complement: \\(-6\\) \u2714\ufe0f (B) - One\u2019s Complement: \\(-5\\) \u2192 Not an option.  </p> <p>Answer: (A) -4 \u274c  </p>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#common-pointer-bugs","title":"\ud83d\uded1 Common Pointer Bugs","text":"<ul> <li>Uninitialized Pointers: C<pre><code>int *p;     // p points to garbage!\n*p = 5;     // Crash/undefined behavior\n</code></pre></li> <li>Memory Leaks: Forgetting to <code>free()</code> after <code>malloc()</code>.  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#key-takeaways","title":"\ud83d\udcd6 Key Takeaways","text":"<ul> <li>C offers low-level control but requires careful memory management.  </li> <li>Pointers = powerful but error-prone. Always initialize!  </li> <li>Structs/unions organize data; padding affects memory layout.  </li> </ul> <p>\ud83d\udd17 Resources: - K&amp;R Book (\"The C Programming Language\") - C99 Standard </p>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/","title":"C strings","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#great-ideas-in-computer-architecture-c-arrays-strings-pointers","title":"\ud83d\udda5\ufe0f Great Ideas in Computer Architecture: C Arrays, Strings, &amp; Pointers","text":"<p> \u7ea6 312 \u4e2a\u5b57  45 \u884c\u4ee3\u7801  1 \u5f20\u56fe\u7247  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 2 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p> <p>Instructor: Jenny Song CS61C su20 - Lecture 3 | 6/26/2020 </p>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#review-of-last-lecture","title":"\ud83d\udcda Review of Last Lecture","text":"<ul> <li>C Basics </li> <li>Variables, Functions, Control Flow, Syntax.  </li> <li>Only <code>0</code> and <code>NULL</code> evaluate to <code>FALSE</code>.  </li> <li>Pointers </li> <li>Hold memory addresses (address vs. value).  </li> <li>Enable efficient code but are error-prone.  </li> <li>Pass by Value </li> <li>C functions pass arguments by value; pointers circumvent this.  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#struct-clarification","title":"\ud83c\udfd7\ufe0f Struct Clarification","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#struct-definition","title":"Struct Definition","text":"C<pre><code>struct foo { /* fields */ };  \nstruct foo name1;         // Declare variable of type struct foo  \nstruct foo* name2;        // Pointer to struct foo  \n</code></pre>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#typedef-with-struct","title":"Typedef with Struct","text":"C<pre><code>// Method 1  \nstruct foo { /* fields */ };  \ntypedef struct foo bar;  \nbar name1;  \n\n// Method 2 (combine definition and typedef)  \ntypedef struct foo { /* fields */ } bar;  \nbar name1;  \n</code></pre>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#great-idea-1-levels-of-representationinterpretation","title":"\ud83c\udf1f Great Idea #1: Levels of Representation/Interpretation","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#agenda","title":"\ud83d\udcdc Agenda","text":"<ol> <li>C Operators  </li> <li>Arrays  </li> <li>Strings  </li> <li>More Pointers (Arithmetic, Misc)  </li> </ol>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#c-operators","title":"\ud83d\udd22 C Operators","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#operator-precedence-table","title":"Operator Precedence Table","text":"Precedence Operator Description Associativity 1 <code>++</code>, <code>--</code> (post) Postfix increment/decrement Left-to-right 1 <code>()</code> Function call 1 <code>[]</code> Array subscripting 2 <code>++</code>, <code>--</code> (pre) Prefix increment/decrement Right-to-left 2 <code>*</code>, <code>&amp;</code> Dereference, Address-of","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#common-pitfalls","title":"Common Pitfalls","text":"<ul> <li>Assignment vs. Equality C<pre><code>a = b;   // Assignment  \na == b;  // Equality test  \n</code></pre></li> <li>Operator Binding </li> <li><code>-x &amp; 1 == 0</code> \u2192 <code>x &amp; (1 == 0)</code> (not <code>(x &amp; 1) == 0</code>).  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#arrays","title":"\ud83d\udce6 Arrays","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#basics","title":"Basics","text":"C<pre><code>int ar;              // Declare 2-element array  \nint ar[] = {795, 635};  // Declare and initialize  \n</code></pre> - Pitfalls: No bounds checking! Accessing <code>ar[n]</code> where <code>n &gt;= 2</code> causes undefined behavior.","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#arrays-vs-pointers","title":"Arrays vs. Pointers","text":"<ul> <li>Similarities: C<pre><code>char* buffer;  // Pointer  \nchar buffer[]; // Array (read-only pointer)  \n</code></pre></li> <li>Differences:  </li> <li><code>sizeof(ar)</code> returns array size; <code>sizeof(ptr)</code> returns pointer size.  </li> <li>Arrays cannot be reassigned (<code>ar = new_array</code> is invalid).  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#example-zeroing-an-array","title":"Example: Zeroing an Array","text":"C<pre><code>// Method 1: Array notation  \nfor (i = 0; i &lt; SIZE; i++) ar[i] = 0;  \n\n// Method 2: Pointer arithmetic  \nfor (i = 0; i &lt; SIZE; i++) *(ar + i) = 0;  \n\n// Method 3: Pointer traversal  \nfor (int* p = ar; p &lt; ar + SIZE; p++) *p = 0;  \n</code></pre>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#strings-in-c","title":"\ud83d\udcdc Strings in C","text":"<ul> <li>Definition: Null-terminated char array. C<pre><code>char s[] = \"abc\";  // Equivalent to {'a', 'b', 'c', '\\0'}  \n</code></pre></li> <li>Common Functions (<code>#include &lt;string.h&gt;</code>):  </li> <li><code>strlen(s)</code>: Returns length (excluding <code>\\0</code>).  </li> <li><code>strcmp(s1, s2)</code>: Returns <code>0</code> if equal.  </li> <li><code>strcpy(dest, src)</code>: Copies <code>src</code> to <code>dest</code>.  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#example","title":"Example","text":"C<pre><code>char s1, s2;  \nstrcpy(s1, \"hi\");  \nstrcpy(s2, \"hi\");  \n</code></pre> - <code>strcmp(s1, s2) == 0</code> \u2192 <code>1</code> (true). - <code>s1 == s2</code> \u2192 <code>0</code> (compares addresses, not content).","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#pointers","title":"\ud83c\udfaf Pointers","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#pointer-arithmetic","title":"Pointer Arithmetic","text":"<ul> <li>Rules:  </li> <li><code>ptr + n</code> adds <code>n * sizeof(*ptr)</code> to the address.  </li> <li>Valid operations: <code>ptr \u00b1 int</code>, subtract pointers, compare pointers.  </li> <li>Example: C<pre><code>int A[] = {5, 10};  \nint* p = A;  \np++;  // Moves to A (address += sizeof(int))  \n</code></pre></li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#pointers-to-pointers","title":"Pointers to Pointers","text":"C<pre><code>void IncrementPtr(int** h) { *h = *h + 1; }  \nint A[] = {50, 60, 70};  \nint* q = A;  \nIncrementPtr(&amp;q);  // q now points to A  \n</code></pre>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#struct-alignment","title":"\ud83e\udde9 Struct Alignment","text":"<ul> <li>Rules:  </li> <li>Members aligned to their size (e.g., <code>int</code> aligned to 4 bytes).  </li> <li>Padding added to meet alignment requirements.  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#example_1","title":"Example","text":"C<pre><code>struct hello {  \n  int a;     // 4 bytes  \n  char b;    // 1 byte (+3 padding)  \n  short c;   // 2 bytes  \n  char* d;   // 4 bytes  \n  char e;    // 1 byte (+3 padding)  \n};  \n// Total size: 4 + (1+3) + 2 + 4 + (1+3) = 16 bytes  \n</code></pre>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#common-pitfalls-tips","title":"\ud83d\udea8 Common Pitfalls &amp; Tips","text":"<ol> <li>Uninitialized Pointers: C<pre><code>int* ptr;  // Points to garbage! Always initialize.  \n</code></pre></li> <li>Array Decay: When passed to functions, arrays decay to pointers (losing size info).  </li> <li>Null Terminator: Forgot <code>\\0</code> in strings? <code>strlen</code> may read garbage!  </li> </ol> <p>\u2728 Key Takeaways: - Arrays and pointers are powerful but error-prone. - Always manage memory carefully and use <code>sizeof()</code> for portability. - Understand alignment to optimize struct layouts!  </p>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/RISC-V/","title":"6 RISC-V","text":""},{"location":"notes/UCB-CS61c/RISC-V/#lecture-notes-risc-v-machine-language","title":"Lecture Notes: RISC-V Machine Language","text":"<p> \u7ea6 266 \u4e2a\u5b57  21 \u884c\u4ee3\u7801  3 \u5f20\u56fe\u7247  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 2 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p>"},{"location":"notes/UCB-CS61c/RISC-V/#registers-in-risc-v","title":"\ud83d\udda5\ufe0f Registers in RISC-V","text":"<ul> <li>32 Registers (<code>x0</code>-<code>x31</code>), each 32-bit wide.</li> <li>Special Registers:</li> <li><code>x0</code> (zero): Always <code>0</code>. </li> <li><code>x1</code> (ra): Return address.</li> <li><code>x2</code> (sp): Stack pointer.</li> <li><code>x8</code> (s0/fp): Saved register/Frame pointer.</li> <li><code>x10</code>-<code>x17</code> (a0-a7): Function arguments/return values.</li> </ul> Register Name Use x0 zero Constant 0 x1 ra Return address x2 sp Stack pointer x8 s0/fp Saved register/Frame pointer x10-x11 a0-a1 Function args/Return values"},{"location":"notes/UCB-CS61c/RISC-V/#basic-risc-v-instructions","title":"\ud83d\udd27 Basic RISC-V Instructions","text":""},{"location":"notes/UCB-CS61c/RISC-V/#1-arithmetic-instructions","title":"1\ufe0f\u20e3 Arithmetic Instructions","text":"<ul> <li>Syntax: <code>op dst, src1, src2</code></li> <li>Examples: GAS<pre><code>add s1, s2, s3   # s1 = s2 + s3\nsub s0, t2, t1   # s0 = t2 - t1\naddi s1, s2, 5   # s1 = s2 + 5 (immediate)\n</code></pre></li> </ul>"},{"location":"notes/UCB-CS61c/RISC-V/#2-data-transfer-instructions","title":"2\ufe0f\u20e3 Data Transfer Instructions","text":"<ul> <li>Load/Store Syntax: <code>memop reg, offset(base)</code></li> <li>Examples: GAS<pre><code>lw t0, 12(s3)    # t0 = Memory[s3 + 12]\nsw t0, 40(s3)    # Memory[s3 + 40] = t0\nlb s1, 1(s0)     # Load byte (sign-extended)\n</code></pre></li> </ul>"},{"location":"notes/UCB-CS61c/RISC-V/#3-control-flow-instructions","title":"3\ufe0f\u20e3 Control Flow Instructions","text":"<ul> <li>Branch/Jump Syntax: <code>beq/bne/blt/bge/j label</code></li> <li>Example (If-Else): GAS<pre><code># C: if (i == j) a = b; else a = -b;\nbeq s0, s1, then   # Branch if i == j\nj else\nthen:\n  add s2, s3, x0   # a = b\n  j end\nelse:\n  sub s2, x0, s3   # a = -b\nend:\n</code></pre></li> </ul>"},{"location":"notes/UCB-CS61c/RISC-V/#example-translating-c-to-risc-v","title":"\ud83e\uddee Example: Translating C to RISC-V","text":""},{"location":"notes/UCB-CS61c/RISC-V/#c-code","title":"C Code:","text":"C<pre><code>a = (b + c) - (d + e);\n</code></pre>"},{"location":"notes/UCB-CS61c/RISC-V/#risc-v-assembly","title":"RISC-V Assembly:","text":"GAS<pre><code>add t1, s3, s4   # t1 = d + e\nadd t2, s1, s2   # t2 = b + c\nsub s0, t2, t1   # a = (b+c) - (d+e)\n</code></pre> - Registers Used:   - <code>a \u2192 s0</code>, <code>b \u2192 s1</code>, <code>c \u2192 s2</code>, <code>d \u2192 s3</code>, <code>e \u2192 s4</code>."},{"location":"notes/UCB-CS61c/RISC-V/#shifting-instructions","title":"\ud83d\udd04 Shifting Instructions","text":"<ul> <li>Examples: GAS<pre><code>slli s0, s1, 3   # s0 = s1 &lt;&lt; 3 (logical left shift)\nsrai s2, t0, 8   # s2 = t0 &gt;&gt; 8 (arithmetic right shift)\n</code></pre></li> </ul>"},{"location":"notes/UCB-CS61c/RISC-V/#risc-v-green-card-key-instructions","title":"\ud83d\udcca RISC-V Green Card (Key Instructions)","text":"Mnemonic Description Example <code>add</code> Add registers <code>add s1, s2, s3</code> <code>addi</code> Add immediate <code>addi s1, s2, 5</code> <code>lw</code> Load word from memory <code>lw t0, 12(s3)</code> <code>sw</code> Store word to memory <code>sw t0, 40(s3)</code> <code>beq</code> Branch if equal <code>beq s0, s1, L1</code> <code>jal</code> Jump and link <code>jal ra, proc</code>"},{"location":"notes/UCB-CS61c/RISC-V/#key-concepts","title":"\ud83e\udde9 Key Concepts","text":"<ol> <li> <p>RISC vs. CISC:    - RISC focuses on simple instructions executed quickly (e.g., ARM, RISC-V).    - CISC uses complex instructions (e.g., x86).  </p> </li> <li> <p>Memory Hierarchy:    - Registers (fastest) \u2192 Cache \u2192 RAM \u2192 Disk (slowest).  </p> </li> <li> <p>Endianness:    - RISC-V uses little-endian (LSB at lowest address).  </p> </li> </ol>"},{"location":"notes/UCB-CS61c/RISC-V/#summary","title":"\ud83d\udcdd Summary","text":"<ul> <li>Registers: Fast, limited storage for variables.  </li> <li>Immediates: Constants embedded in instructions (e.g., <code>addi</code>).  </li> <li>Control Flow: Branches (<code>beq</code>, <code>bne</code>) and jumps (<code>j</code>, <code>jal</code>).  </li> <li>Data Transfer: Load/store instructions for memory access.  </li> </ul> <p>\ud83d\ude80 RISC-V is dominant in embedded systems, academia, and modern computing!</p> <p>\ud83d\udcf8 PPT Screenshots (Hypothetical Links): </p> <p>Note: Replace image links with actual screenshots of full PPT slides.</p>"},{"location":"notes/UCB-CS61c/float%20point/","title":"5 float points","text":""},{"location":"notes/UCB-CS61c/float%20point/#instructor-jenny-song","title":"Instructor: Jenny Song \ud83d\udc69\ud83c\udfeb","text":"<p> \u7ea6 297 \u4e2a\u5b57  9 \u884c\u4ee3\u7801  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 2 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p>"},{"location":"notes/UCB-CS61c/float%20point/#table-of-contents","title":"Table of Contents \ud83d\udcda","text":"<ol> <li>Review of C Memory Layout</li> <li>Floating Point Representation</li> <li>IEEE 754 Standard</li> <li>Special Cases &amp; Limitations</li> <li>Examples &amp; Practice</li> </ol>"},{"location":"notes/UCB-CS61c/float%20point/#review-c-memory-layout","title":"Review: C Memory Layout \ud83e\udde0","text":"C<pre><code>+------------------+\n|       Stack      | \ud83d\udc49 Local variables (LIFO)\n+------------------+\n|    Static Data   | \ud83d\udc49 Global variables &amp; string literals\n+------------------+\n|       Code       | \ud83d\udc49 Machine code copy\n+------------------+\n|       Heap       | \ud83d\udc49 Dynamic storage (malloc/free)\n+------------------+\n</code></pre> <ul> <li>Memory Bugs often arise from stack/heap collisions (OS prevents via virtual memory).</li> </ul>"},{"location":"notes/UCB-CS61c/float%20point/#floating-point-representation","title":"Floating Point Representation \ud83c\udf0c","text":""},{"location":"notes/UCB-CS61c/float%20point/#key-ideas","title":"Key Ideas:","text":"<ul> <li>Scientific Notation: Normalized form ensures one non-zero digit left of the decimal point.</li> <li>Example: <code>1.0 \u00d7 10\u207b\u2079</code> (normalized) vs. <code>0.1 \u00d7 10\u207b\u2078</code> (not normalized).</li> <li>Binary Scientific Notation: Text Only<pre><code>1.0101_{two} \\times 2^4 = 10110_{two} = 22_{ten}\n</code></pre></li> </ul>"},{"location":"notes/UCB-CS61c/float%20point/#6-bit-fixed-binary-point-example","title":"6-Bit Fixed Binary Point Example:","text":"<ul> <li>Representation: <code>XX.XXXX</code> (e.g., <code>10.1010_{two} = 2.625_{ten}</code>).</li> <li>Range: <code>0</code> to <code>3.9375</code> (smallest difference = <code>2\u207b\u2074 = 1/16</code>).</li> </ul>"},{"location":"notes/UCB-CS61c/float%20point/#ieee-754-floating-point-standard","title":"IEEE 754 Floating Point Standard \ud83c\udfdb\ufe0f","text":""},{"location":"notes/UCB-CS61c/float%20point/#single-precision-32-bits","title":"Single Precision (32 bits):","text":"Text Only<pre><code>(-1)^S \\times (1.\\text{Significand}) \\times 2^{\\text{(Exponent - 127)}}\n</code></pre> Bit 31 Bits 30-23 (Exponent) Bits 22-0 (Significand) S (1) 8 bits (Biased) 23 bits (Fraction) <ul> <li>Exponent Bias: <code>127</code> (actual exponent = <code>Exponent field - 127</code>).</li> <li>Implicit Leading 1: Significand assumes <code>1.xxx...</code>, e.g., <code>1.1010...</code>.</li> </ul>"},{"location":"notes/UCB-CS61c/float%20point/#double-precision-64-bits","title":"Double Precision (64 bits):","text":"<ul> <li>Larger significand (52 bits) and exponent bias <code>1023</code>.</li> </ul>"},{"location":"notes/UCB-CS61c/float%20point/#special-cases-limitations","title":"Special Cases &amp; Limitations \u26a0\ufe0f","text":""},{"location":"notes/UCB-CS61c/float%20point/#encodings-summary","title":"Encodings Summary:","text":"Exponent Significand Meaning Example (Hex) 0 0 \u00b10 <code>0x00000000</code> (\uff0b0) 0 \u22600 Denormalized Gradual underflow 1-254 Any Normalized Float <code>0x40400000</code> = <code>3.0</code> 255 0 \u00b1\u221e <code>0x7F800000</code> (\uff0b\u221e) 255 \u22600 NaN Result of <code>0/0</code> or <code>\u221a(-1)</code>"},{"location":"notes/UCB-CS61c/float%20point/#key-notes","title":"Key Notes:","text":"<ul> <li>Two Zeros: <code>+0</code> and <code>-0</code> (same value, different sign bits).</li> <li>Infinity: Result of overflow (e.g., division by zero).</li> <li>NaN: \"Not a Number\" for undefined operations.</li> </ul>"},{"location":"notes/UCB-CS61c/float%20point/#examples-practice","title":"Examples &amp; Practice \ud83d\udca1","text":""},{"location":"notes/UCB-CS61c/float%20point/#example-1-convert-to-single-precision","title":"Example 1: Convert to Single-Precision","text":"<p>Value: <code>-3.75</code> 1. Sign: <code>S = 1</code> (negative). 2. Binary Fraction: <code>3.75 = 11.11_{two} = 1.111_{two} \u00d7 2^1</code>. 3. Exponent: <code>1 + 127 = 128</code> \u2192 <code>10000000_{two}</code>. 4. Significand: <code>111000...0</code> (23 bits).</p> <p>Encoding: </p>Text Only<pre><code>1 10000000 11100000000000000000000\n</code></pre>"},{"location":"notes/UCB-CS61c/float%20point/#example-2-decode-single-precision","title":"Example 2: Decode Single-Precision","text":"<p>Hex: <code>0xC0A00000</code> 1. Binary: <code>1 10000001 01000000000000000000000</code>. 2. Sign: Negative (<code>S=1</code>). 3. Exponent: <code>129 - 127 = 2</code>. 4. Significand: <code>1.010000... = 1.25_{ten}</code>. 5. Value: <code>-1.25 \u00d7 2^2 = -5.0</code>.</p>"},{"location":"notes/UCB-CS61c/float%20point/#practice-problems","title":"Practice Problems \ud83d\udcdd","text":"<ol> <li> <p>Convert <code>12.375</code> to IEEE 754 single-precision.    - Answer: <code>0x41460000</code>.</p> </li> <li> <p>Decode <code>0x3F800000</code>.    - Answer: <code>1.0</code> (S=0, Exponent=127, Significand=1.0).</p> </li> </ol>"},{"location":"notes/UCB-CS61c/float%20point/#key-takeaways","title":"Key Takeaways \ud83d\ude80","text":"<ul> <li>Floating point trades precision for range.</li> <li>IEEE 754 ensures consistency across systems.</li> <li>Special values (<code>\u00b10</code>, <code>\u00b1\u221e</code>, <code>NaN</code>) handle edge cases gracefully.</li> </ul>"},{"location":"summary/","title":"index","text":""},{"location":"summary/#summaries","title":"Summaries \ud83d\uddd3\ufe0f","text":"\u300e \u0915\u093f\u0928\u094d\u0928\u0930\u093f\u092f \u092e\u092e \u0924\u0923\u094d\u0939\u093e \u300f"},{"location":"summary/2025/summary-1/","title":"2025 \u5468\u7ed3 1","text":"<p> \u7ea6 0 \u4e2a\u5b57  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4\u4e0d\u5230 1 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p>","tags":["summary"]},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tags","title":"Tags","text":"<p>{{ tag_content }}</p>"}]}