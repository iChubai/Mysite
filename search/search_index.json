{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Welcome to HouJiadong's Site! \ud83c\udf89  <p>  My frineds! /  About Me /   Academic Page /  Statistics </p> <li>Website Operating Time: </li> <li>Total Visitors:  people</li> <li>Total Visits:  times</li>"},{"location":"academy/","title":"Jiadong Hou(\u4faf\u5609\u680b)","text":""},{"location":"academy/#jiadong-hou","title":"Jiadong Hou(\u4faf\u5609\u680b)","text":"<p> Work Email: 2311671 [at] mail [at] nankai [dot] edu [dot] cn</p> <p> Personal Email: 2506676943 [at] qq [dot] com</p> <p> CV: Click Here</p> <p> </p>"},{"location":"academy/#bio","title":"Bio","text":"<p>I am a second-year undergraduate student majoring in Computer Science at  Nankai University (NKU). Currently, I am an intern at Hvision, under the guidance of Prof. Qibin Hou.</p>"},{"location":"academy/#research-interest","title":"Research Interest","text":"<ul> <li>Computer Vision: I am committed to the CV field, especially in the field of visual object tracking and kownledge distillation.</li> </ul>"},{"location":"academy/#education","title":"Education","text":""},{"location":"academy/#college-of-computer-science-nankai-university","title":"College of Computer Science, Nankai University","text":"<p>Sept. 2023 -- Present</p>"},{"location":"academy/#publications-manuscripts","title":"Publications &amp; Manuscripts","text":"<p>Coming soon...</p>"},{"location":"academy/#experience","title":"Experience","text":"<p>VCIP</p> <p>Dec. 2024 - Present</p> <p>Research Intern</p>"},{"location":"academy/#projects","title":"Projects","text":"<p>Coming soon...</p>"},{"location":"academy/#media-exposures","title":"Media Exposures","text":"<p>I write articles and share my thinkings on Zhihu regularly and have 200+ followers so far!</p>"},{"location":"academy/#honors","title":"Honors","text":"<ul> <li>Scholarship of Public Interests and All-Round Capability, 2024 </li> <li>Second Prize of the National College Students Mathematical Modeling Contest (Tianjin Division)</li> <li>First prize of the 16<sup>th</sup> Chinese Mathematics Competitions and first prize of the  Tianjin Mathematics Competitions(2024)</li> </ul>"},{"location":"about/","title":"About","text":""},{"location":"about/#about","title":"About \ud83e\udd73","text":"<p> \u7ea6 70 \u4e2a\u5b57  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4\u4e0d\u5230 1 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p> \u4e2d\u6587English <p>\u6211\u662f\u5357\u5f00\u5927\u5b66\u8ba1\u7b97\u673a\u79d1\u5b66\u4e0e\u6280\u672f\u4e13\u4e1a\u7684\u5927\u4e8c\u672c\u79d1\u751f\uff0c\u76ee\u524d\u611f\u5174\u8da3\u7684\u65b9\u5411\u662f\u8ba1\u7b97\u673a\u89c6\u89c9\uff08CV\uff09\u3002\u591a\u591a\u6307\u6559~    </p> <p>I am a sophomore in Nankai University majoring in Computer Science and Technology. My interests are in computer vision (CV). Thank you for your guidance!</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/#blog","title":"Blog","text":"<p> \u7ea6 1 \u4e2a\u5b57  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4\u4e0d\u5230 1 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p>"},{"location":"blogs/","title":"index","text":""},{"location":"blogs/#blogs","title":"Blogs \u270d","text":"<p>Abstract</p> <p>\u4e2a\u4eba\u535a\u5ba2\uff0c\u4e3b\u8981\u8bb0\u5f55</p> <ul> <li>\u5728\u8ba1\u7b97\u673a\u3001\u4eba\u5de5\u667a\u80fd\u3001\u6570\u5b66\u76f8\u5173\u65b9\u9762\u7684\u5b66\u4e60\uff0c\u4e5f\u4f1a\u63ba\u6742\u4e00\u4e9b\u5176\u5b83\u7684\u9886\u57df\uff1b</li> <li>\u8bfb\u4e66\u6458\u5f55\uff0c\u53ef\u80fd\u4f1a\u6709\u4e00\u4e9b\u7b14\u8bb0\uff1b</li> <li>\u4e00\u4e9b\u6742\u8c08\u3002</li> </ul> <p>\u4e00\u4e9b\u6bd4\u8f83\u6210\u4f53\u7cfb\u7684\u7b14\u8bb0\u4f1a\u8bb0\u5f55\u5728 Notes \u4e2d\u3002</p> <p>\u672c\u90e8\u5206\u5185\u5bb9\uff08\u9664\u7279\u522b\u58f0\u660e\u5916\uff09\u91c7\u7528 \u7f72\u540d-\u975e\u5546\u4e1a\u6027\u4f7f\u7528-\u4fdd\u6301\u4e00\u81f4 4.0 \u56fd\u9645 (CC BY-NC-SA 4.0) \u8bb8\u53ef\u534f\u8bae\u8fdb\u884c\u8bb8\u53ef\u3002</p>"},{"location":"blogs/#archives","title":"Archives","text":"<p>\u5982\u679c\u5bfb\u627e\u4e0d\u65b9\u4fbf\u7684\u8bdd\uff0c\u4e0d\u59a8\u8bd5\u8bd5\u641c\u7d22\u6216\u8005\u524d\u5f80 Tags \u9875\u9762</p> <p>{{ blog_content }}</p>"},{"location":"links/","title":"Links","text":""},{"location":"links/#links","title":"Links \ud83e\udd70","text":"<p>Abstract</p> <p>My friends!</p> Kinnariya Mama Tanha's Blogs \u5927\u4f6c(\u5d07\u62dc\u8138qwq) <p>\u5728\u4e0b\u65b9\u7559\u8a00\u7533\u8bf7\u52a0\u5165\u6211\u7684\u53cb\u94fe\uff0c\u6309\u5982\u4e0b\u683c\u5f0f\u63d0\u4f9b\u4fe1\u606f\uff1a</p> <ul><li>\u540d\u79f0\uff1aKinnari's Site</li><li>\u7b80\u4ecb\uff1aKinnariya Mama Tanha</li><li>\u94fe\u63a5\uff1ahttps://kinnariyamamatanha.github.io/</li><li>\u56fe\u7247\uff1aLink of your avatar</li></ul>"},{"location":"notes/","title":"index","text":""},{"location":"notes/#notes","title":"Notes \ud83d\udcda","text":"<p>Abstract</p> <p>\u4e00\u4e9b\u6bd4\u8f83\u6210\u4f53\u7cfb\u7684\u7b14\u8bb0\u90fd\u505a\u5728\u8fd9\u91cc\uff0c\u65b9\u4fbf\u67e5\u9605\u3002</p> <p>\u672c\u90e8\u5206\u5185\u5bb9\uff08\u9664\u7279\u522b\u58f0\u660e\u5916\uff09\u91c7\u7528 \u7f72\u540d-\u975e\u5546\u4e1a\u6027\u4f7f\u7528-\u4fdd\u6301\u4e00\u81f4 4.0 \u56fd\u9645 (CC BY-NC-SA 4.0) \u8bb8\u53ef\u534f\u8bae\u8fdb\u884c\u8bb8\u53ef\u3002</p>"},{"location":"notes/MIT6.046/FFT/","title":"2 FFT","text":""},{"location":"notes/MIT6.046/FFT/#polynomial-operations-and-representation","title":"Polynomial Operations and Representation","text":"<p> \u7ea6 496 \u4e2a\u5b57  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 2 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p> <p>A polynomial \\(A(x)\\) can be written in the following forms: $$ \\begin{aligned} A(x) &amp;= a_0 + a_1x + a_2x^2 + \\cdots + a_{n-1}x^{n-1}   \\\\ &amp;= \\sum_{k=0}^{n-1} a_k x^k   \\\\ &amp;= \\left\\langle a_0, a_1, a_2, \\ldots, a_{n-1} \\right\\rangle \\quad \\text{(coefficient vector)} \\end{aligned} $$</p>"},{"location":"notes/MIT6.046/FFT/#the-degree-of-a-is-n-1","title":"The degree of \\(A\\) is \\(n-1\\)","text":""},{"location":"notes/MIT6.046/FFT/#operations-on-polynomials","title":"Operations on Polynomials","text":"<ol> <li> <p>Evaluation: Given \\( A(x) \\) and \\( x_0 \\), compute \\( A(x_0) \\).    - Horner's Rule:      $$      A(x) = a_0 + x\\left(a_1 + x\\left(a_2 + \\cdots + x\\left(a_{n-1}\\right)\\cdots\\right)\\right)      $$ Time: \\( O(n) \\).</p> </li> <li> <p>Addition: \\( C(x) = A(x) + B(x) \\).    - \\( c_k = a_k + b_k \\). Time: \\( O(n) \\).</p> </li> <li> <p>Multiplication: \\( C(x) = A(x) \\cdot B(x) \\).    - \\( c_k = \\sum_{j=0}^k a_j b_{k-j} \\).    - Naive Time: \\( O(n^2) \\).    - FFT Time: \\( O(n \\log n) \\).</p> </li> </ol>"},{"location":"notes/MIT6.046/FFT/#representations-of-polynomials","title":"Representations of Polynomials","text":"Representation Evaluation Addition Multiplication Coefficients \\( O(n) \\) \\( O(n) \\) \\( O(n^2) \\) Roots \\( O(n) \\) Impossible \\( O(n) \\) Samples \\( O(n^2) \\) \\( O(n) \\) \\( O(n) \\) <p>Key Insight: Convert between coefficients and samples in \\( O(n \\log n) \\) time using FFT.</p>"},{"location":"notes/MIT6.046/FFT/#divide-and-conquer-algorithm-for-polynomial-multiplication","title":"Divide and Conquer Algorithm for Polynomial Multiplication","text":"<ol> <li> <p>Divide: Split \\( A(x) \\) into even and odd coefficients:    $$    \\begin{aligned}    A_{\\text{even}}(x) &amp;= \\sum_{k=0}^{\\lceil n/2 \\rceil -1} a_{2k} x^k, \\\\    A_{\\text{odd}}(x) &amp;= \\sum_{k=0}^{\\lfloor n/2 \\rfloor -1} a_{2k+1} x^k.    \\end{aligned}    $$</p> </li> <li> <p>Conquer: Recursively compute \\( A_{\\text{even}}(y) \\) and \\( A_{\\text{odd}}(y) \\) for \\( y \\in X^2 \\).  </p> </li> <li> <p>Combine:    $$    A(x) = A_{\\text{even}}(x^2) + x \\cdot A_{\\text{odd}}(x^2)    $$</p> </li> </ol> <p>Recurrence: $$ T(n) = 2T\\left(\\frac{n}{2}\\right) + O(n) = O(n \\log n) $$</p>"},{"location":"notes/MIT6.046/FFT/#roots-of-unity","title":"Roots of Unity","text":"<p>Definition: The \\(n\\) -th roots of unity are \\(x\\) such that \\(x^n = 1\\). They are spaced uniformly on the unit circle in the complex plane: $$ x_k = e^{i \\tau k / n}, \\quad k = 0, 1, \\ldots, n - 1 \\quad (\\tau = 2\\pi) $$</p> <p>Collapsing Property: For \\(n = 2^\\ell\\), squaring the roots reduces the problem size by half: $$ \\left(e^{i \\tau k / n}\\right)^2 = e^{i \\tau k / (n/2)} $$</p>"},{"location":"notes/MIT6.046/FFT/#fft-and-ifft","title":"FFT and IFFT","text":""},{"location":"notes/MIT6.046/FFT/#fast-fourier-transform-fft","title":"Fast Fourier Transform (FFT)","text":"<ul> <li>DFT: Convert coefficients to samples using roots of unity:  </li> </ul> \\[ A^* = V \\cdot A \\quad \\text{where } V_{jk} = e^{i \\tau jk / n} \\] <ul> <li>Time: \\(O(n \\log n)\\)</li> </ul>"},{"location":"notes/MIT6.046/FFT/#inverse-fft-ifft","title":"Inverse FFT (IFFT)","text":"<ul> <li>IDFT: Convert samples back to coefficients:  </li> </ul> \\[ A = \\frac{1}{n} \\bar{V} \\cdot A^* \\] <ul> <li>Time: \\(O(n \\log n)\\)</li> </ul>"},{"location":"notes/MIT6.046/FFT/#polynomial-multiplication-via-fft","title":"Polynomial Multiplication via FFT","text":"<p>Steps:  </p> <ol> <li>Compute \\(A^*= \\text{FFT}(A)\\) and \\(B^* = \\text{FFT}(B)\\).  </li> <li>Multiply samples: \\(C^*= A^* \\cdot B^*\\).  </li> <li>Convert back: \\(C = \\text{IFFT}(C^*)\\).  </li> </ol> <p>Example:  </p> <ul> <li>Let \\(A(x) = 1 + 2x\\) and \\(B(x) = 3 + 4x\\).  </li> <li>FFT:  </li> <li>\\(A^*= [3, -1]\\), \\(B^* = [7, -1]\\).  </li> <li>Multiply: \\(C^* = [21, 1]\\).  </li> <li>IFFT: \\(C(x) = 3 + 10x + 8x^2\\).  </li> </ul> <p>Analysis:  </p> <ul> <li>Naive multiplication: \\(O(n^2) = O(4)\\).  </li> <li>FFT - based: \\(O(n \\log n) = O(2 \\log 2)\\).  </li> </ul>"},{"location":"notes/MIT6.046/FFT/#applications-of-fft","title":"Applications of FFT","text":"<ul> <li>Signal Processing: Filtering, compression (MP3), spectral analysis.  </li> <li>Algorithm Design: Convolution, large integer multiplication.  </li> </ul>"},{"location":"notes/MIT6.046/Interval%20Scheduling/","title":"1 Interval Scheduling","text":""},{"location":"notes/MIT6.046/Interval%20Scheduling/#course-overview","title":"Course Overview","text":"<p> \u7ea6 403 \u4e2a\u5b57  4 \u5f20\u56fe\u7247  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 2 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p> <ul> <li>Modules Covered:   1. Divide and Conquer (FFT, Randomized algorithms)   2. Optimization (greedy, dynamic programming)   3. Network Flow   4. Intractibility and coping strategies   5. Linear Programming   6. Sublinear and Approximation Algorithms   7. Advanced Topics</li> </ul>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#key-complexity-classes","title":"Key Complexity Classes","text":"<ul> <li>P: Solvable in polynomial time (e.g., shortest paths in \\(O(V^2)\\)).</li> <li>NP: Verifiable in polynomial time (e.g., Hamiltonian Cycle detection is NP-complete, but verification is easy).</li> <li>NP-Complete: A problem in NP that is as hard as any problem in NP. Solving one in polynomial time would solve all NP problems.</li> </ul>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#interval-scheduling","title":"Interval Scheduling","text":"<p>Problem: Select a maximum subset of non-overlapping requests. Each request has: - Start time \\(s(i)\\) - Finish time \\(f(i)\\) (with \\(s(i) &lt; f(i)\\))  </p> <p>Compatibility: Two requests \\(i\\) and \\(j\\) are compatible if: \\(\\(f(i) \\leq s(j) \\quad \\text{or} \\quad f(j) \\leq s(i)\\)\\)</p> <p>Example:  Requests 2 &amp; 3 are compatible; 4, 5, 6 are compatible; 2 &amp; 4 are not.</p>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#greedy-algorithms-for-interval-scheduling","title":"Greedy Algorithms for Interval Scheduling","text":"<p>Claim: Greedy algorithm with earliest finish time yields an optimal solution.  </p>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#possible-greedy-rules","title":"Possible Greedy Rules:","text":"<ol> <li> <p>Earliest Start Time Fails for overlapping long intervals.</p> </li> <li> <p>Smallest Interval Fails if small intervals block larger compatible ones.</p> </li> <li> <p>Fewest Conflicts Computationally expensive to track conflicts.</p> </li> <li> <p>Earliest Finish Time Optimal.</p> </li> </ol>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#proof-of-optimality-for-earliest-finish-time","title":"Proof of Optimality for Earliest Finish Time","text":"<p>Inductive Proof: - Base Case: \\(k^* = 1\\) \u2013 trivial. - Inductive Step: Assume optimality holds for \\(k^*\\). For \\(k^* + 1\\):   - Let \\(S^*\\) be the optimal schedule. Greedy picks \\(i_1\\) with \\(f(i_1) \\leq f(j_1)\\).   - Construct \\(S^{**} = \\{i_1, j_2, \\ldots, j_{k^*+1}\\}\\), which is also optimal.   - Residual problem \\(L'\\) (intervals after \\(f(i_1)\\)) has optimal size \\(k^*\\). By induction, greedy on \\(L'\\) gives \\(k^*\\) intervals.   - Total schedule size: \\(1 + k^* = k^* + 1\\).  </p>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#weighted-interval-scheduling","title":"Weighted Interval Scheduling","text":"<p>Problem: Maximize total weight of non-overlapping requests. - Greedy fails due to weights. - Dynamic Programming Approach:   Define \\(R^x = \\{j \\mid s(j) \\geq x\\}\\). Recurrence: \\(\\(\\text{opt}(R) = \\max_{1 \\leq i \\leq n} \\left( w(i) + \\text{opt}(R^{f(i)}) \\right)\\)\\)   - Time: \\(O(n^2)\\) (can be optimized to \\(O(n \\log n)\\)).  </p>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#non-identical-machines","title":"Non-Identical Machines","text":"<p>Problem: Schedule jobs on \\(m\\) machines where each job \\(i\\) can only run on a subset \\(Q(i) \\subseteq \\{T_1, \\ldots, T_m\\}\\). - Complexity:   - Decision version (\"Can \\(k \\leq n\\) jobs be scheduled?\") is NP-Complete.   - Optimization version (\"Maximize scheduled jobs\") is NP-Hard.  </p>"},{"location":"notes/MIT6.046/Interval%20Scheduling/#coping-with-intractability","title":"Coping with Intractability","text":"<ol> <li>Approximation Algorithms: Guarantee near-optimal solutions in polynomial time.  </li> <li>Pruning Heuristics: Reduce search space for practical instances.  </li> <li>Greedy Heuristics: No guarantees but perform well empirically.  </li> </ol>"},{"location":"notes/UCB-CS61c/1-intro/","title":"Intro","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/1-intro/#intro","title":"Intro","text":"<p> \u7ea6 154 \u4e2a\u5b57  1 \u5f20\u56fe\u7247  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 1 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p> <p>title: Intro math: false tags:   - CS61C</p>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/1-intro/#great-ideas","title":"Great Ideas","text":"<ol> <li>Abstraction: Levels of Representation / Interpretation </li> <li>Moore's Law: Designing through trends</li> <li>Principle of Locality: Memory Hierarchy</li> <li>Parallelism &amp; Amdahl's law</li> <li>Dependability via Redundancy</li> </ol>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/1-intro/#number-representations","title":"Number Representations","text":"<ul> <li>Bit: 0/1</li> <li>Byte: 8 bits</li> <li>Most Significant Bit (MSB)</li> <li>Least Significant Bit (LSB)</li> <li>One's Complement: <code>-x=~x</code><ul> <li>Neg: \\([-(2^{n-1}-1),-0]\\)</li> <li>Pos: \\([0, 2^{n-1}-1]\\)</li> </ul> </li> <li>Two's Complement: <code>-x=~x+1</code><ul> <li>Neg: \\([-2^{n-1},-1]\\)</li> <li>Pos: \\([0, 2^{n-1}-1]\\)</li> </ul> </li> <li>Bias encoding: \u4f8b\u5982\u60f3\u8981\u5229\u7528 4 \u4f4d bits \u4ee3\u8868 \\([-3,12]\\)\uff0c\u53ea\u9700\u53d6 bias \u4e3a \\(-3\\)\uff0c\u5229\u7528 \\([0,15]\\) \u6765\u8868\u793a<ul> <li>\u5bf9 two's complement\uff0cbias \u4e3a \\(N=-2^{n-1}+1\\)\uff0c\u4e0d\u8fc7 \\(-2^{n-1} - N=-1\\)\uff0c\u800c\u4e0d\u662f \\(0\\) </li> <li>\u8fd9\u662f\u56e0\u4e3a\u5728 floating representations \u4e2d\uff0c\u5168\u4e3a \\(1\\) \u7684\u6570\u6709\u7279\u6b8a\u7528\u9014</li> <li>\u4f8b\u5982\uff1a <code>0b1010</code> \u7684 bias \u4e3a \\(-2^{4-1}+1=-7\\), \u8fd9\u4e2a\u6570\u4e3a \\(10-(-7)=3\\)</li> </ul> </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20memory%20management/","title":"4 C memory management","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#c-memory-management-usage-comprehensive-notes","title":"\ud83e\udde0 C Memory Management &amp; Usage - Comprehensive Notes","text":"<p> \u7ea6 411 \u4e2a\u5b57  38 \u884c\u4ee3\u7801  4 \u5f20\u56fe\u7247  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 3 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#table-of-contents","title":"\ud83d\udcda Table of Contents","text":"<ol> <li>C Memory Layout</li> <li>Addressing &amp; Endianness</li> <li>Dynamic Memory Allocation</li> <li>Common Memory Problems</li> <li>Linked List Example</li> <li>Memory Fragmentation &amp; K&amp;R Algorithm</li> <li>Debugging Tools</li> </ol>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#c-memory-layout","title":"\ud83d\uddfa\ufe0f C Memory Layout","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#program-address-space","title":"Program Address Space","text":"<ul> <li>4 Regions:   1. Stack \ud83d\udce5  <ul> <li>Stores local variables (declared inside functions).  </li> <li>Grows downward.  </li> <li>Freed when function returns.  </li> <li>Example: <code>int x = 5;</code> inside <code>main()</code>.</li> </ul> </li> </ul> <ol> <li> <p>Heap \ud83e\uddf1  </p> <ul> <li>Dynamically allocated via <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code>.  </li> <li>Grows upward.  </li> <li>Must be explicitly freed with <code>free()</code>.  </li> <li>Example: <code>int *arr = malloc(10 * sizeof(int));</code>.</li> </ul> </li> <li> <p>Static Data \ud83c\udf10  </p> <ul> <li>Stores global/static variables and string literals.  </li> <li>Does not grow/shrink.  </li> <li>Example: <code>char *str = \"hello\";</code> (string literal in static data).  </li> <li>\u26a0\ufe0f <code>char str[] = \"hello\";</code> stores the array on the stack!</li> </ul> </li> <li> <p>Code \ud83d\udcdc  </p> <ul> <li>Contains compiled machine code.  </li> <li>Read-only and immutable.</li> </ul> </li> </ol>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#addressing-endianness","title":"\ud83d\udd22 Addressing &amp; Endianness","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#key-concepts","title":"Key Concepts","text":"<ul> <li>Byte-Addressed Machines: Each address points to a unique byte.  </li> <li>Word-Addressed Machines: Each address points to a word (group of bytes).  </li> <li>Endianness: Order of bytes in multi-byte data types.  </li> </ul>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#types-of-endianness","title":"Types of Endianness","text":"<ol> <li>Big Endian \ud83d\udc18    - Most significant byte at lowest address.    - Example: <code>0x12345678</code> stored as <code>12 34 56 78</code>.  </li> <li>Little Endian \ud83d\udc2d    - Least significant byte at lowest address.    - Example: <code>0x12345678</code> stored as <code>78 56 34 12</code>.  </li> </ol>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#example-integer-28-0x0000001c","title":"Example: Integer <code>28</code> (0x0000001C)","text":"<ul> <li>Big Endian: <code>00 00 00 1C</code> </li> <li>Little Endian: <code>1C 00 00 00</code> </li> </ul>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#dynamic-memory-allocation","title":"\ud83d\udca5 Dynamic Memory Allocation","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#functions","title":"Functions","text":"<ol> <li><code>malloc(n)</code>    - Allocates <code>n</code> bytes of uninitialized memory.    - Example: C<pre><code>int *arr = (int*)malloc(5 * sizeof(int)); // Allocate space for 5 integers\n</code></pre></li> <li><code>calloc(n, size)</code>    - Allocates <code>n * size</code> bytes initialized to zero.    - Example: C<pre><code>int *arr = (int*)calloc(5, sizeof(int)); // [0, 0, 0, 0, 0]\n</code></pre></li> <li><code>realloc(ptr, new_size)</code>    - Resizes existing memory block.    - May move the block to a new address.    - Example: C<pre><code>arr = realloc(arr, 10 * sizeof(int)); // Expand to 10 integers\n</code></pre></li> <li><code>free(ptr)</code>    - Releases memory.    - \u26a0\ufe0f Never free:  <ul> <li>Stack variables.  </li> <li>Already freed memory.  </li> <li>Middle of a block (e.g., <code>free(arr + 1)</code>).</li> </ul> </li> </ol>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#common-memory-problems","title":"\ud83d\udea8 Common Memory Problems","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#1-using-uninitialized-values","title":"1. Using Uninitialized Values","text":"C<pre><code>int *p;\nprintf(\"%d\", *p); // Undefined behavior! p points to garbage.\n</code></pre>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#2-using-memory-you-dont-own","title":"2. Using Memory You Don\u2019t Own","text":"<ul> <li>Example 1: Returning a stack-allocated array. C<pre><code>char* func() {\n    char arr;\n    return arr; // \u274c arr is on the stack; invalid after function returns.\n}\n</code></pre></li> <li>Example 2: Buffer overflow. C<pre><code>char buf;\nstrcpy(buf, \"This is too long!\"); // Writes beyond buf\n</code></pre></li> </ul>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#3-freeing-invalid-memory","title":"3. Freeing Invalid Memory","text":"<ul> <li>Double Free: C<pre><code>int *p = malloc(4);\nfree(p);\nfree(p); // \u274c p already freed.\n</code></pre></li> <li>Freeing Stack Variable: C<pre><code>int x = 5;\nfree(&amp;x); // \u274c x is on the stack.\n</code></pre></li> </ul>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#4-memory-leaks","title":"4. Memory Leaks","text":"<ul> <li>Example: Overwriting a pointer before freeing. C<pre><code>int *p = malloc(4);\np = malloc(8); // \u274c Original 4 bytes are now unreachable.\n</code></pre></li> </ul>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#linked-list-example","title":"\ud83d\udd17 Linked List Example","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#node-structure","title":"Node Structure","text":"C<pre><code>struct Node {\n    char *value;\n    struct Node *next;\n};\n</code></pre>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#adding-a-node","title":"Adding a Node","text":"C<pre><code>struct Node* addNode(char *s, struct Node *list) {\n    struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode-&gt;value = (char*)malloc(strlen(s) + 1); // +1 for '\\0'\n    strcpy(newNode-&gt;value, s);\n    newNode-&gt;next = list;\n    return newNode;\n}\n</code></pre>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#freeing-a-node","title":"Freeing a Node","text":"C<pre><code>void freeList(struct Node *list) {\n    while (list != NULL) {\n        struct Node *temp = list;\n        list = list-&gt;next;\n        free(temp-&gt;value); // Free the string\n        free(temp);        // Free the node\n    }\n}\n</code></pre>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#visualization","title":"Visualization","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#memory-fragmentation-kr-algorithm","title":"\ud83e\udde9 Memory Fragmentation &amp; K&amp;R Algorithm","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#fragmentation-example","title":"Fragmentation Example","text":""},{"location":"notes/UCB-CS61c/C%20memory%20management/#kr-allocation-strategy","title":"K&amp;R Allocation Strategy","text":"<ul> <li>Free List: Linked list of free memory blocks.  </li> <li>Merging Adjacent Blocks: <code>free()</code> combines adjacent free blocks.  </li> <li>Allocation Policies:  </li> <li>First Fit: Use the first block that fits.  </li> <li>Best Fit: Use the smallest block that fits.  </li> <li>Next Fit: Resume search from last position.</li> </ul>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#debugging-tools","title":"\ud83d\udee0\ufe0f Debugging Tools","text":"<ul> <li>Valgrind \ud83e\uddea: Detects memory leaks, invalid accesses, and more. Bash<pre><code>valgrind --leak-check=full ./your_program\n</code></pre></li> <li>Example Output: Text Only<pre><code>==12345== Invalid write of size 4\n==12345==    at 0x400ABC: main (example.c:10)\n</code></pre></li> </ul>"},{"location":"notes/UCB-CS61c/C%20memory%20management/#summary","title":"\ud83d\udccc Summary","text":"<ul> <li>Stack: Local variables, LIFO.  </li> <li>Heap: Dynamic, manually managed.  </li> <li>Static Data: Globals &amp; literals.  </li> <li>Code: Immutable.  </li> <li>Common Pitfalls: Leaks, invalid accesses, uninitialized values.  </li> <li>Golden Rule: Always pair <code>malloc()</code> with <code>free()</code>! \ud83d\uded1</li> </ul>"},{"location":"notes/UCB-CS61c/C%20pointers/","title":"C pointers","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#cs61c-lecture-notes-introduction-to-c-pointers","title":"\ud83d\udcda CS61C Lecture Notes: Introduction to C &amp; Pointers","text":"<p> \u7ea6 282 \u4e2a\u5b57  34 \u884c\u4ee3\u7801  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 2 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p> <p>Instructor: Stephan Kaminsky | Date: Jun 2019  </p>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#key-concepts-in-c-programming","title":"\ud83d\udccc Key Concepts in C Programming","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#1-compilation-in-c","title":"1. Compilation in C","text":"<ul> <li>Compiled Language: Converts C code directly to machine-specific instructions (0s and 1s).  </li> <li>\ud83d\ude80 Advantages: Faster execution than Java/Python (no bytecode/JVM).  </li> <li>\u26a0\ufe0f Disadvantages: Platform-dependent executables; slower edit-compile-run cycle.  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#2-variable-types-declarations","title":"2. Variable Types &amp; Declarations","text":"<ul> <li>Typed Variables: Must declare type before use.  </li> <li>Example: C<pre><code>int x = 5;          // Integer\nfloat y = 1.618;    // Floating point\nchar z = 'A';       // Character\n</code></pre></li> <li>Type Sizes: Machine-dependent (e.g., <code>int</code> = 4/8 bytes).  </li> <li>Special Keywords: <code>short</code>, <code>long</code>, <code>unsigned</code>.  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#3-characters-ascii","title":"3. Characters &amp; ASCII","text":"<ul> <li>ASCII Encoding: Characters stored as numbers (e.g., <code>'a'</code> = 97). C<pre><code>char c = 'a';     // Same as char c = 97;\n</code></pre></li> <li>Size: 1 byte (8 bits).  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#4-type-casting","title":"4. Type Casting","text":"<ul> <li>Weak Typing: Explicitly cast between types.  </li> <li>Example: C<pre><code>int i = -1;\nif ((unsigned int)i &lt; 0) { ... }  // False\n</code></pre></li> <li>\u26a0\ufe0f Caution: Risky casts (e.g., casting structs to integers).  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#5-functions","title":"5. Functions","text":"<ul> <li>Prototypes &amp; Definitions: C<pre><code>int add(int a, int b);   // Prototype\nint add(int a, int b) { return a + b; }  // Definition\n</code></pre></li> <li>Return Types: Must declare return type (<code>void</code> for no return).  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#6-structs-unions","title":"6. Structs &amp; Unions","text":"<ul> <li>Structs: Group related variables. C<pre><code>typedef struct {\n  int length;\n  int year;\n} Song;\nSong s = {213, 1994}; \n</code></pre></li> <li>Unions: Overlapping memory for different types. C<pre><code>union Data {\n  int i;\n  float f;\n};\n</code></pre></li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#example-struct-padding","title":"\ud83e\uddee Example: Struct Padding","text":"C<pre><code>struct foo {\n  int a;     // 4 bytes\n  char b;    // 1 byte (+3 padding)\n  struct foo* c;  // 4 bytes\n};  \n// Total size = 12 bytes (32-bit architecture)\n</code></pre>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#c-vs-java-comparison","title":"\ud83d\udcca C vs Java Comparison","text":"Feature C Java Language Type Function-Oriented Object-Oriented Memory Management Manual (<code>malloc</code>, <code>free</code>) Automatic (Garbage Collection) Hello World <code>printf(\"Hello\\n\");</code> <code>System.out.println(...);</code>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#pointers-address-vs-value","title":"\ud83c\udfaf Pointers: Address vs Value","text":"<ul> <li>Pointer Syntax: C<pre><code>int y = 5;\nint *p = &amp;y;   // p stores address of y\nint z = *p;    // z = value at address p (5)\n</code></pre></li> <li>Pointer Types:  </li> <li><code>int*</code>, <code>char*</code>, <code>void*</code> (generic pointer).  </li> <li>\u26a0\ufe0f Dangling Pointers: Uninitialized pointers \u2192 undefined behavior!  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#example-pointer-parameter-passing","title":"\ud83d\udd0d Example: Pointer Parameter Passing","text":"C<pre><code>void addOne(int *p) { (*p)++; }  \nint main() {\n  int y = 3;\n  addOne(&amp;y);    // y becomes 4\n  return 0;\n}\n</code></pre>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#quiz-4-bit-number-representations","title":"\u2753 Quiz: 4-Bit Number Representations","text":"<p>Given <code>x = 0b1010</code> (4 bits), which value does NOT represent <code>x</code>?  </p> <p>Options: (A) -4 \u2003(B) -6\u2003(C) 10\u2003(D) -2  </p> <p>Analysis: - Unsigned: \\(2^3 + 2^1 = 10\\) \u2714\ufe0f (C) - Sign &amp; Magnitude: \\(-2^1 = -2\\) \u2714\ufe0f (D) - Biased (Bias=7): \\(10 - 7 = 3\\) \u2192 Not an option. - Two\u2019s Complement: \\(-6\\) \u2714\ufe0f (B) - One\u2019s Complement: \\(-5\\) \u2192 Not an option.  </p> <p>Answer: (A) -4 \u274c  </p>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#common-pointer-bugs","title":"\ud83d\uded1 Common Pointer Bugs","text":"<ul> <li>Uninitialized Pointers: C<pre><code>int *p;     // p points to garbage!\n*p = 5;     // Crash/undefined behavior\n</code></pre></li> <li>Memory Leaks: Forgetting to <code>free()</code> after <code>malloc()</code>.  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20pointers/#key-takeaways","title":"\ud83d\udcd6 Key Takeaways","text":"<ul> <li>C offers low-level control but requires careful memory management.  </li> <li>Pointers = powerful but error-prone. Always initialize!  </li> <li>Structs/unions organize data; padding affects memory layout.  </li> </ul> <p>\ud83d\udd17 Resources: - K&amp;R Book (\"The C Programming Language\") - C99 Standard </p>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/","title":"C strings","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#great-ideas-in-computer-architecture-c-arrays-strings-pointers","title":"\ud83d\udda5\ufe0f Great Ideas in Computer Architecture: C Arrays, Strings, &amp; Pointers","text":"<p> \u7ea6 312 \u4e2a\u5b57  45 \u884c\u4ee3\u7801  1 \u5f20\u56fe\u7247  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 2 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p> <p>Instructor: Jenny Song CS61C su20 - Lecture 3 | 6/26/2020 </p>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#review-of-last-lecture","title":"\ud83d\udcda Review of Last Lecture","text":"<ul> <li>C Basics </li> <li>Variables, Functions, Control Flow, Syntax.  </li> <li>Only <code>0</code> and <code>NULL</code> evaluate to <code>FALSE</code>.  </li> <li>Pointers </li> <li>Hold memory addresses (address vs. value).  </li> <li>Enable efficient code but are error-prone.  </li> <li>Pass by Value </li> <li>C functions pass arguments by value; pointers circumvent this.  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#struct-clarification","title":"\ud83c\udfd7\ufe0f Struct Clarification","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#struct-definition","title":"Struct Definition","text":"C<pre><code>struct foo { /* fields */ };  \nstruct foo name1;         // Declare variable of type struct foo  \nstruct foo* name2;        // Pointer to struct foo  \n</code></pre>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#typedef-with-struct","title":"Typedef with Struct","text":"C<pre><code>// Method 1  \nstruct foo { /* fields */ };  \ntypedef struct foo bar;  \nbar name1;  \n\n// Method 2 (combine definition and typedef)  \ntypedef struct foo { /* fields */ } bar;  \nbar name1;  \n</code></pre>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#great-idea-1-levels-of-representationinterpretation","title":"\ud83c\udf1f Great Idea #1: Levels of Representation/Interpretation","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#agenda","title":"\ud83d\udcdc Agenda","text":"<ol> <li>C Operators  </li> <li>Arrays  </li> <li>Strings  </li> <li>More Pointers (Arithmetic, Misc)  </li> </ol>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#c-operators","title":"\ud83d\udd22 C Operators","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#operator-precedence-table","title":"Operator Precedence Table","text":"Precedence Operator Description Associativity 1 <code>++</code>, <code>--</code> (post) Postfix increment/decrement Left-to-right 1 <code>()</code> Function call 1 <code>[]</code> Array subscripting 2 <code>++</code>, <code>--</code> (pre) Prefix increment/decrement Right-to-left 2 <code>*</code>, <code>&amp;</code> Dereference, Address-of","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#common-pitfalls","title":"Common Pitfalls","text":"<ul> <li>Assignment vs. Equality C<pre><code>a = b;   // Assignment  \na == b;  // Equality test  \n</code></pre></li> <li>Operator Binding </li> <li><code>-x &amp; 1 == 0</code> \u2192 <code>x &amp; (1 == 0)</code> (not <code>(x &amp; 1) == 0</code>).  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#arrays","title":"\ud83d\udce6 Arrays","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#basics","title":"Basics","text":"C<pre><code>int ar;              // Declare 2-element array  \nint ar[] = {795, 635};  // Declare and initialize  \n</code></pre> - Pitfalls: No bounds checking! Accessing <code>ar[n]</code> where <code>n &gt;= 2</code> causes undefined behavior.","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#arrays-vs-pointers","title":"Arrays vs. Pointers","text":"<ul> <li>Similarities: C<pre><code>char* buffer;  // Pointer  \nchar buffer[]; // Array (read-only pointer)  \n</code></pre></li> <li>Differences:  </li> <li><code>sizeof(ar)</code> returns array size; <code>sizeof(ptr)</code> returns pointer size.  </li> <li>Arrays cannot be reassigned (<code>ar = new_array</code> is invalid).  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#example-zeroing-an-array","title":"Example: Zeroing an Array","text":"C<pre><code>// Method 1: Array notation  \nfor (i = 0; i &lt; SIZE; i++) ar[i] = 0;  \n\n// Method 2: Pointer arithmetic  \nfor (i = 0; i &lt; SIZE; i++) *(ar + i) = 0;  \n\n// Method 3: Pointer traversal  \nfor (int* p = ar; p &lt; ar + SIZE; p++) *p = 0;  \n</code></pre>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#strings-in-c","title":"\ud83d\udcdc Strings in C","text":"<ul> <li>Definition: Null-terminated char array. C<pre><code>char s[] = \"abc\";  // Equivalent to {'a', 'b', 'c', '\\0'}  \n</code></pre></li> <li>Common Functions (<code>#include &lt;string.h&gt;</code>):  </li> <li><code>strlen(s)</code>: Returns length (excluding <code>\\0</code>).  </li> <li><code>strcmp(s1, s2)</code>: Returns <code>0</code> if equal.  </li> <li><code>strcpy(dest, src)</code>: Copies <code>src</code> to <code>dest</code>.  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#example","title":"Example","text":"C<pre><code>char s1, s2;  \nstrcpy(s1, \"hi\");  \nstrcpy(s2, \"hi\");  \n</code></pre> - <code>strcmp(s1, s2) == 0</code> \u2192 <code>1</code> (true). - <code>s1 == s2</code> \u2192 <code>0</code> (compares addresses, not content).","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#pointers","title":"\ud83c\udfaf Pointers","text":"","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#pointer-arithmetic","title":"Pointer Arithmetic","text":"<ul> <li>Rules:  </li> <li><code>ptr + n</code> adds <code>n * sizeof(*ptr)</code> to the address.  </li> <li>Valid operations: <code>ptr \u00b1 int</code>, subtract pointers, compare pointers.  </li> <li>Example: C<pre><code>int A[] = {5, 10};  \nint* p = A;  \np++;  // Moves to A (address += sizeof(int))  \n</code></pre></li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#pointers-to-pointers","title":"Pointers to Pointers","text":"C<pre><code>void IncrementPtr(int** h) { *h = *h + 1; }  \nint A[] = {50, 60, 70};  \nint* q = A;  \nIncrementPtr(&amp;q);  // q now points to A  \n</code></pre>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#struct-alignment","title":"\ud83e\udde9 Struct Alignment","text":"<ul> <li>Rules:  </li> <li>Members aligned to their size (e.g., <code>int</code> aligned to 4 bytes).  </li> <li>Padding added to meet alignment requirements.  </li> </ul>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#example_1","title":"Example","text":"C<pre><code>struct hello {  \n  int a;     // 4 bytes  \n  char b;    // 1 byte (+3 padding)  \n  short c;   // 2 bytes  \n  char* d;   // 4 bytes  \n  char e;    // 1 byte (+3 padding)  \n};  \n// Total size: 4 + (1+3) + 2 + 4 + (1+3) = 16 bytes  \n</code></pre>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/C%20strings/#common-pitfalls-tips","title":"\ud83d\udea8 Common Pitfalls &amp; Tips","text":"<ol> <li>Uninitialized Pointers: C<pre><code>int* ptr;  // Points to garbage! Always initialize.  \n</code></pre></li> <li>Array Decay: When passed to functions, arrays decay to pointers (losing size info).  </li> <li>Null Terminator: Forgot <code>\\0</code> in strings? <code>strlen</code> may read garbage!  </li> </ol> <p>\u2728 Key Takeaways: - Arrays and pointers are powerful but error-prone. - Always manage memory carefully and use <code>sizeof()</code> for portability. - Understand alignment to optimize struct layouts!  </p>","tags":["CS61C"]},{"location":"notes/UCB-CS61c/float%20point/","title":"Float point","text":""},{"location":"notes/UCB-CS61c/float%20point/#instructor-jenny-song","title":"Instructor: Jenny Song \ud83d\udc69\ud83c\udfeb","text":"<p> \u7ea6 297 \u4e2a\u5b57  9 \u884c\u4ee3\u7801  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4 2 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p>"},{"location":"notes/UCB-CS61c/float%20point/#table-of-contents","title":"Table of Contents \ud83d\udcda","text":"<ol> <li>Review of C Memory Layout</li> <li>Floating Point Representation</li> <li>IEEE 754 Standard</li> <li>Special Cases &amp; Limitations</li> <li>Examples &amp; Practice</li> </ol>"},{"location":"notes/UCB-CS61c/float%20point/#review-c-memory-layout","title":"Review: C Memory Layout \ud83e\udde0","text":"C<pre><code>+------------------+\n|       Stack      | \ud83d\udc49 Local variables (LIFO)\n+------------------+\n|    Static Data   | \ud83d\udc49 Global variables &amp; string literals\n+------------------+\n|       Code       | \ud83d\udc49 Machine code copy\n+------------------+\n|       Heap       | \ud83d\udc49 Dynamic storage (malloc/free)\n+------------------+\n</code></pre> <ul> <li>Memory Bugs often arise from stack/heap collisions (OS prevents via virtual memory).</li> </ul>"},{"location":"notes/UCB-CS61c/float%20point/#floating-point-representation","title":"Floating Point Representation \ud83c\udf0c","text":""},{"location":"notes/UCB-CS61c/float%20point/#key-ideas","title":"Key Ideas:","text":"<ul> <li>Scientific Notation: Normalized form ensures one non-zero digit left of the decimal point.</li> <li>Example: <code>1.0 \u00d7 10\u207b\u2079</code> (normalized) vs. <code>0.1 \u00d7 10\u207b\u2078</code> (not normalized).</li> <li>Binary Scientific Notation: Text Only<pre><code>1.0101_{two} \\times 2^4 = 10110_{two} = 22_{ten}\n</code></pre></li> </ul>"},{"location":"notes/UCB-CS61c/float%20point/#6-bit-fixed-binary-point-example","title":"6-Bit Fixed Binary Point Example:","text":"<ul> <li>Representation: <code>XX.XXXX</code> (e.g., <code>10.1010_{two} = 2.625_{ten}</code>).</li> <li>Range: <code>0</code> to <code>3.9375</code> (smallest difference = <code>2\u207b\u2074 = 1/16</code>).</li> </ul>"},{"location":"notes/UCB-CS61c/float%20point/#ieee-754-floating-point-standard","title":"IEEE 754 Floating Point Standard \ud83c\udfdb\ufe0f","text":""},{"location":"notes/UCB-CS61c/float%20point/#single-precision-32-bits","title":"Single Precision (32 bits):","text":"Text Only<pre><code>(-1)^S \\times (1.\\text{Significand}) \\times 2^{\\text{(Exponent - 127)}}\n</code></pre> Bit 31 Bits 30-23 (Exponent) Bits 22-0 (Significand) S (1) 8 bits (Biased) 23 bits (Fraction) <ul> <li>Exponent Bias: <code>127</code> (actual exponent = <code>Exponent field - 127</code>).</li> <li>Implicit Leading 1: Significand assumes <code>1.xxx...</code>, e.g., <code>1.1010...</code>.</li> </ul>"},{"location":"notes/UCB-CS61c/float%20point/#double-precision-64-bits","title":"Double Precision (64 bits):","text":"<ul> <li>Larger significand (52 bits) and exponent bias <code>1023</code>.</li> </ul>"},{"location":"notes/UCB-CS61c/float%20point/#special-cases-limitations","title":"Special Cases &amp; Limitations \u26a0\ufe0f","text":""},{"location":"notes/UCB-CS61c/float%20point/#encodings-summary","title":"Encodings Summary:","text":"Exponent Significand Meaning Example (Hex) 0 0 \u00b10 <code>0x00000000</code> (\uff0b0) 0 \u22600 Denormalized Gradual underflow 1-254 Any Normalized Float <code>0x40400000</code> = <code>3.0</code> 255 0 \u00b1\u221e <code>0x7F800000</code> (\uff0b\u221e) 255 \u22600 NaN Result of <code>0/0</code> or <code>\u221a(-1)</code>"},{"location":"notes/UCB-CS61c/float%20point/#key-notes","title":"Key Notes:","text":"<ul> <li>Two Zeros: <code>+0</code> and <code>-0</code> (same value, different sign bits).</li> <li>Infinity: Result of overflow (e.g., division by zero).</li> <li>NaN: \"Not a Number\" for undefined operations.</li> </ul>"},{"location":"notes/UCB-CS61c/float%20point/#examples-practice","title":"Examples &amp; Practice \ud83d\udca1","text":""},{"location":"notes/UCB-CS61c/float%20point/#example-1-convert-to-single-precision","title":"Example 1: Convert to Single-Precision","text":"<p>Value: <code>-3.75</code> 1. Sign: <code>S = 1</code> (negative). 2. Binary Fraction: <code>3.75 = 11.11_{two} = 1.111_{two} \u00d7 2^1</code>. 3. Exponent: <code>1 + 127 = 128</code> \u2192 <code>10000000_{two}</code>. 4. Significand: <code>111000...0</code> (23 bits).</p> <p>Encoding: </p>Text Only<pre><code>1 10000000 11100000000000000000000\n</code></pre>"},{"location":"notes/UCB-CS61c/float%20point/#example-2-decode-single-precision","title":"Example 2: Decode Single-Precision","text":"<p>Hex: <code>0xC0A00000</code> 1. Binary: <code>1 10000001 01000000000000000000000</code>. 2. Sign: Negative (<code>S=1</code>). 3. Exponent: <code>129 - 127 = 2</code>. 4. Significand: <code>1.010000... = 1.25_{ten}</code>. 5. Value: <code>-1.25 \u00d7 2^2 = -5.0</code>.</p>"},{"location":"notes/UCB-CS61c/float%20point/#practice-problems","title":"Practice Problems \ud83d\udcdd","text":"<ol> <li> <p>Convert <code>12.375</code> to IEEE 754 single-precision.    - Answer: <code>0x41460000</code>.</p> </li> <li> <p>Decode <code>0x3F800000</code>.    - Answer: <code>1.0</code> (S=0, Exponent=127, Significand=1.0).</p> </li> </ol>"},{"location":"notes/UCB-CS61c/float%20point/#key-takeaways","title":"Key Takeaways \ud83d\ude80","text":"<ul> <li>Floating point trades precision for range.</li> <li>IEEE 754 ensures consistency across systems.</li> <li>Special values (<code>\u00b10</code>, <code>\u00b1\u221e</code>, <code>NaN</code>) handle edge cases gracefully.</li> </ul>"},{"location":"summary/","title":"index","text":""},{"location":"summary/#summaries","title":"Summaries \ud83d\uddd3\ufe0f","text":"\u300e \u0915\u093f\u0928\u094d\u0928\u0930\u093f\u092f \u092e\u092e \u0924\u0923\u094d\u0939\u093e \u300f"},{"location":"summary/2025/summary-1/","title":"2025 \u5468\u7ed3 1","text":"<p> \u7ea6 0 \u4e2a\u5b57  \u9884\u8ba1\u9605\u8bfb\u65f6\u95f4\u4e0d\u5230 1 \u5206\u949f  \u5171\u88ab\u8bfb\u8fc7  \u6b21</p>","tags":["summary"]},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tags","title":"Tags","text":"<p>{{ tag_content }}</p>"}]}